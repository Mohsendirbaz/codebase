# ModEcon System Refactoring: Matrix-Based Implementation Plan

This comprehensive plan provides step-by-step instructions for refactoring the ModEcon system to implement a matrix-based version management approach, synchronizing form values and scaling items, and extending efficacy capabilities.

## Phase 1: Core Matrix Structure and State Management

### Step 1: Create Matrix-Based Atoms for Form Values

```javascript
// src/atoms/matrixFormValues.js
import { atom } from 'jotai';
import { propertyMapping, defaultValues } from '../utils/formMetadata';

// Version and zone management
export const versionsAtom = atom({
  list: ["v1"],  // List of all versions
  active: "v1",  // Currently active version
  metadata: {
    "v1": {
      label: "Base Case",
      description: "Default financial case",
      created: Date.now(),
      modified: Date.now()
    }
  }
});

export const zonesAtom = atom({
  list: ["z1"],  // List of all zones
  active: "z1",  // Currently active zone
  metadata: {
    "z1": {
      label: "Local",
      description: "Local market zone",
      created: Date.now()
    }
  }
});

// Matrix-based form values atom
export const formValuesMatrixAtom = atom({});

// Initialize matrix structure for each form value
export const initializeFormValueMatrixAtom = atom(
  null,
  (get, set) => {
    const versions = get(versionsAtom);
    const zones = get(zonesAtom);

    // Create matrix structure for each parameter
    const formValuesMatrix = {};

    Object.keys(propertyMapping).forEach(paramId => {
      const isNumber = typeof defaultValues[paramId] === 'number';
      const defaultValue = defaultValues[paramId] !== undefined ? defaultValues[paramId] : '';

      // Initialize matrix structure for this parameter
      const paramMatrix = {
        id: paramId,
        label: propertyMapping[paramId],
        type: isNumber ? 'number' : 'text',
        versions: {},
        zones: {},
        matrix: {},
        inheritance: {},
        dynamicAppendix: {
          scaling: {
            type: null,
            factor: 1,
            operation: 'multiply',
            enabled: false,
            baseValue: defaultValue,
            scaledValue: defaultValue,
            notes: ''
          },
          group: { id: null, name: null, isProtected: false },
          itemState: {
            vKey: paramId.includes('vAmount') ?
              `V${parseInt(paramId.replace('vAmount', ''))}` : null,
            rKey: paramId.includes('rAmount') ?
              `R${parseInt(paramId.replace('rAmount', ''))}` : null,
            fKey: paramId.includes('Amount') &&
              parseInt(paramId.replace(/\D/g, '')) >= 34 &&
              parseInt(paramId.replace(/\D/g, '')) <= 38 ?
              `F${parseInt(paramId.replace(/\D/g, '')) - 33}` : null,
            rfKey: paramId.includes('Amount') &&
              parseInt(paramId.replace(/\D/g, '')) >= 80 &&
              parseInt(paramId.replace(/\D/g, '')) <= 84 ?
              `RF${parseInt(paramId.replace(/\D/g, '')) - 79}` : null,
            sKey: paramId.includes('Amount') ?
              `S${parseInt(paramId.replace(/\D/g, ''))}` : null,
            status: 'off'
          }
        },
        efficacyPeriod: {
          start: { value: 0 },
          end: { value: defaultValues['plantLifetimeAmount10'] || 20 }
        }
      };

      // Initialize versions
      versions.list.forEach(versionId => {
        paramMatrix.versions[versionId] = {
          label: versions.metadata[versionId].label,
          isActive: versionId === versions.active
        };

        paramMatrix.matrix[versionId] = {};
        paramMatrix.inheritance[versionId] = {
          source: null,
          percentage: 100 // Default to no inheritance
        };
      });

      // Initialize zones
      zones.list.forEach(zoneId => {
        paramMatrix.zones[zoneId] = {
          label: zones.metadata[zoneId].label,
          isActive: zoneId === zones.active
        };

        // Initialize matrix values for each version and zone
        versions.list.forEach(versionId => {
          paramMatrix.matrix[versionId][zoneId] = defaultValue;
        });
      });

      formValuesMatrix[paramId] = paramMatrix;
    });

    set(formValuesMatrixAtom, formValuesMatrix);
  }
);

// Get current value based on active version and zone
export const getCurrentValueAtom = atom(
  (get) => (paramId) => {
    const formMatrix = get(formValuesMatrixAtom);
    const versions = get(versionsAtom);
    const zones = get(zonesAtom);

    if (!formMatrix[paramId]) return null;

    const activeVersion = versions.active;
    const activeZone = zones.active;

    return formMatrix[paramId].matrix[activeVersion]?.[activeZone] || null;
  }
);

// Update matrix value with inheritance calculation
export const updateMatrixValueAtom = atom(
  null,
  (get, set, { paramId, versionId, zoneId, value }) => {
    const formMatrix = get(formValuesMatrixAtom);
    const versions = get(versionsAtom);
    const zones = get(zonesAtom);

    if (!formMatrix[paramId]) return false;

    // Determine which version and zone to use
    const targetVersion = versionId || versions.active;
    const targetZone = zoneId || zones.active;

    // Create a deep copy to avoid mutations
    const updatedMatrix = { ...formMatrix };
    const updatedParam = { ...updatedMatrix[paramId] };

    // Update matrix for the target version and zone
    if (!updatedParam.matrix[targetVersion]) {
      updatedParam.matrix[targetVersion] = {};
    }

    updatedParam.matrix[targetVersion][targetZone] = value;
    updatedMatrix[paramId] = updatedParam;

    // Apply inheritance if needed
    Object.keys(updatedParam.inheritance).forEach(version => {
      const inheritance = updatedParam.inheritance[version];
      if (inheritance.source === targetVersion && inheritance.percentage < 100) {
        const sourceValue = updatedParam.matrix[targetVersion][targetZone];
        const currentValue = updatedParam.matrix[version][targetZone];
        const inheritPercent = inheritance.percentage / 100;

        // Calculate new value based on inheritance
        // inherited value = (original * (1 - inherit%)) + (source * inherit%)
        const newValue = (currentValue * (1 - inheritPercent)) + (sourceValue * inheritPercent);
        updatedParam.matrix[version][targetZone] = newValue;
      }
    });

    set(formValuesMatrixAtom, updatedMatrix);
    return true;
  }
);

// Configure inheritance between versions
export const configureInheritanceAtom = atom(
  null,
  (get, set, { paramId, versionId, sourceVersionId, percentage }) => {
    const formMatrix = get(formValuesMatrixAtom);

    if (!formMatrix[paramId]) return false;

    // Update inheritance configuration
    const updatedMatrix = { ...formMatrix };
    const updatedParam = { ...updatedMatrix[paramId] };

    updatedParam.inheritance[versionId] = {
      source: sourceVersionId,
      percentage: Math.min(100, Math.max(0, percentage))
    };

    updatedMatrix[paramId] = updatedParam;
    set(formValuesMatrixAtom, updatedMatrix);

    return true;
  }
);
```

### Step 2: Extend Efficacy Support to Scaling Items

```javascript
// src/atoms/efficacyMatrix.js
import { atom } from 'jotai';
import { formValuesMatrixAtom, versionsAtom, zonesAtom } from './matrixFormValues';
import { scalingGroupsAtom } from './scaling';

// Extended efficacy period atom for scaling items
export const extendedEfficacyPeriodsAtom = atom({});

// Initialize efficacy periods for scaling items
export const initializeEfficacyPeriodsAtom = atom(
  null,
  (get, set) => {
    const formMatrix = get(formValuesMatrixAtom);
    const scalingGroups = get(scalingGroupsAtom);
    const plantLifetime = formMatrix.plantLifetimeAmount10?.matrix[get(versionsAtom).active][get(zonesAtom).active] || 20;

    const efficacyPeriods = {};

    // Initialize for scaling groups and items
    scalingGroups.forEach(group => {
      // Group level efficacy
      efficacyPeriods[`group_${group.id}`] = {
        type: 'group',
        id: group.id,
        name: group.name,
        start: 0,
        end: plantLifetime,
        isCustomized: false,
        overridesItems: false // If true, group efficacy overrides item efficacy
      };

      // Item level efficacy
      group.items.forEach(item => {
        // Find corresponding form value if it exists
        const formItem = formMatrix[item.id];

        efficacyPeriods[`item_${item.id}`] = {
          type: 'item',
          id: item.id,
          groupId: group.id,
          start: formItem?.efficacyPeriod?.start?.value || 0,
          end: formItem?.efficacyPeriod?.end?.value || plantLifetime,
          isCustomized: formItem ?
            (formItem.efficacyPeriod?.start?.value > 0 ||
             formItem.efficacyPeriod?.end?.value < plantLifetime) : false,
          // Priority settings for conflict resolution
          priority: 'item', // 'item', 'group', or 'value'
          // Reference to corresponding form value efficacy
          formValueRef: formItem ? item.id : null
        };
      });
    });

    set(extendedEfficacyPeriodsAtom, efficacyPeriods);
  }
);

// Update efficacy period for scaling item with sync options
export const updateScalingItemEfficacyAtom = atom(
  null,
  (get, set, { itemId, start, end, syncToFormValue = true, syncFromFormValue = false, priority = 'item' }) => {
    const efficacyPeriods = get(extendedEfficacyPeriodsAtom);
    const formMatrix = get(formValuesMatrixAtom);
    const plantLifetime = formMatrix.plantLifetimeAmount10?.matrix[get(versionsAtom).active][get(zonesAtom).active] || 20;

    // Ensure start <= end <= plantLifetime
    const validStart = Math.max(0, Math.min(start, end, plantLifetime));
    const validEnd = Math.max(validStart, Math.min(end, plantLifetime));

    // Update the efficacy period for the scaling item
    const updatedEfficacyPeriods = { ...efficacyPeriods };
    const itemKey = `item_${itemId}`;

    if (!updatedEfficacyPeriods[itemKey]) {
      // Create new entry if it doesn't exist
      updatedEfficacyPeriods[itemKey] = {
        type: 'item',
        id: itemId,
        groupId: null, // Will be set later if item is part of a group
        start: validStart,
        end: validEnd,
        isCustomized: validStart > 0 || validEnd < plantLifetime,
        priority: priority,
        formValueRef: null
      };
    } else {
      // Update existing entry
      updatedEfficacyPeriods[itemKey] = {
        ...updatedEfficacyPeriods[itemKey],
        start: validStart,
        end: validEnd,
        isCustomized: validStart > 0 || validEnd < plantLifetime,
        priority: priority
      };
    }

    // Sync with form value if requested and reference exists
    if (syncToFormValue && updatedEfficacyPeriods[itemKey].formValueRef) {
      const formValueId = updatedEfficacyPeriods[itemKey].formValueRef;

      // Clone form matrix for updating
      const updatedFormMatrix = { ...formMatrix };
      const targetForm = { ...updatedFormMatrix[formValueId] };

      // Update efficacy period in form value
      targetForm.efficacyPeriod = {
        ...targetForm.efficacyPeriod,
        start: { ...targetForm.efficacyPeriod.start, value: validStart },
        end: { ...targetForm.efficacyPeriod.end, value: validEnd }
      };

      updatedFormMatrix[formValueId] = targetForm;
      set(formValuesMatrixAtom, updatedFormMatrix);
    }

    set(extendedEfficacyPeriodsAtom, updatedEfficacyPeriods);
    return true;
  }
);

// Efficacy-aware scaling groups atom
export const efficacyAwareScalingGroupsAtom = atom(
  (get) => {
    const scalingGroups = get(scalingGroupsAtom);
    const efficacyPeriods = get(extendedEfficacyPeriodsAtom);
    const formMatrix = get(formValuesMatrixAtom);
    const currentTime = get(simulationTimeAtom) || 0;

    // Apply efficacy periods to scaling groups and items
    return scalingGroups.map(group => {
      // Check group efficacy
      const groupEfficacy = efficacyPeriods[`group_${group.id}`];
      const groupIsActive = !groupEfficacy ||
        (currentTime >= groupEfficacy.start && currentTime <= groupEfficacy.end);

      return {
        ...group,
        isActive: groupIsActive,
        efficacyPeriod: groupEfficacy ? {
          start: groupEfficacy.start,
          end: groupEfficacy.end,
          isCustomized: groupEfficacy.isCustomized
        } : null,
        items: group.items.map(item => {
          // Check item efficacy
          const itemEfficacy = efficacyPeriods[`item_${item.id}`];

          // Determine if item is active based on efficacy periods
          // If group overrides items, use group efficacy
          // Otherwise, use item efficacy if available, then form value efficacy
          let isActive = true;
          let effectiveEfficacy = null;

          if (groupEfficacy?.overridesItems) {
            isActive = groupIsActive;
            effectiveEfficacy = groupEfficacy;
          } else if (itemEfficacy) {
            isActive = currentTime >= itemEfficacy.start && currentTime <= itemEfficacy.end;
            effectiveEfficacy = itemEfficacy;
          } else if (formMatrix[item.id]?.efficacyPeriod) {
            const formEfficacy = formMatrix[item.id].efficacyPeriod;
            isActive = currentTime >= formEfficacy.start.value && currentTime <= formEfficacy.end.value;
            effectiveEfficacy = {
              start: formEfficacy.start.value,
              end: formEfficacy.end.value,
              isCustomized: formEfficacy.start.value > 0 ||
                formEfficacy.end.value < (formMatrix.plantLifetimeAmount10?.matrix[get(versionsAtom).active][get(zonesAtom).active] || 20)
            };
          }

          return {
            ...item,
            isActive,
            // Use scaledValue when active, baseValue when inactive
            effectiveValue: isActive ? item.scaledValue : item.baseValue,
            efficacyPeriod: effectiveEfficacy ? {
              start: effectiveEfficacy.start,
              end: effectiveEfficacy.end,
              isCustomized: effectiveEfficacy.isCustomized
            } : null
          };
        })
      };
    });
  }
);

// Simulation time for efficacy calculations
export const simulationTimeAtom = atom(0);
```

### Step 3: Implement Matrix-Based History Tracking

```javascript
// src/atoms/matrixHistory.js
import { atom } from 'jotai';
import { formValuesMatrixAtom } from './matrixFormValues';
import { versionsAtom, zonesAtom } from './matrixFormValues';
import { scalingGroupsAtom } from './scaling';
import { extendedEfficacyPeriodsAtom } from './efficacyMatrix';

// History entries atom
export const historyEntriesAtom = atom([]);
export const historyIndexAtom = atom(0);

// Create a complete state snapshot
export const createStateSnapshotAtom = atom(
  (get) => ({
    timestamp: Date.now(),
    formMatrix: get(formValuesMatrixAtom),
    versions: get(versionsAtom),
    zones: get(zonesAtom),
    scalingGroups: get(scalingGroupsAtom),
    efficacyPeriods: get(extendedEfficacyPeriodsAtom)
  })
);

// Add history entry
export const addHistoryEntryAtom = atom(
  null,
  (get, set, { action, description }) => {
    const snapshot = get(createStateSnapshotAtom);
    const currentIndex = get(historyIndexAtom);
    const entries = get(historyEntriesAtom);

    const newEntry = {
      id: `history_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,
      timestamp: Date.now(),
      action,
      description,
      snapshot
    };

    // Truncate history if not at latest entry
    const newEntries = entries.slice(0, currentIndex + 1);
    newEntries.push(newEntry);

    set(historyEntriesAtom, newEntries);
    set(historyIndexAtom, newEntries.length - 1);
  }
);

// Undo action
export const undoAtom = atom(
  null,
  (get, set) => {
    const currentIndex = get(historyIndexAtom);
    if (currentIndex <= 0) return false;

    const newIndex = currentIndex - 1;
    const entries = get(historyEntriesAtom);
    const snapshot = entries[newIndex].snapshot;

    // Restore all state from snapshot
    set(formValuesMatrixAtom, snapshot.formMatrix);
    set(versionsAtom, snapshot.versions);
    set(zonesAtom, snapshot.zones);
    set(scalingGroupsAtom, snapshot.scalingGroups);
    set(extendedEfficacyPeriodsAtom, snapshot.efficacyPeriods);

    set(historyIndexAtom, newIndex);
    return true;
  }
);

// Redo action
export const redoAtom = atom(
  null,
  (get, set) => {
    const currentIndex = get(historyIndexAtom);
    const entries = get(historyEntriesAtom);

    if (currentIndex >= entries.length - 1) return false;

    const newIndex = currentIndex + 1;
    const snapshot = entries[newIndex].snapshot;

    // Restore all state from snapshot
    set(formValuesMatrixAtom, snapshot.formMatrix);
    set(versionsAtom, snapshot.versions);
    set(zonesAtom, snapshot.zones);
    set(scalingGroupsAtom, snapshot.scalingGroups);
    set(extendedEfficacyPeriodsAtom, snapshot.efficacyPeriods);

    set(historyIndexAtom, newIndex);
    return true;
  }
);

// Export history for persistence
export const exportHistoryAtom = atom(
  (get) => ({
    entries: get(historyEntriesAtom),
    currentIndex: get(historyIndexAtom)
  })
);

// Import history
export const importHistoryAtom = atom(
  null,
  (get, set, historyData) => {
    if (!historyData?.entries?.length) return false;

    set(historyEntriesAtom, historyData.entries);
    set(historyIndexAtom, historyData.currentIndex || 0);

    // Restore state from current history entry
    const currentEntry = historyData.entries[historyData.currentIndex || 0];
    if (currentEntry?.snapshot) {
      set(formValuesMatrixAtom, currentEntry.snapshot.formMatrix);
      set(versionsAtom, currentEntry.snapshot.versions);
      set(zonesAtom, currentEntry.snapshot.zones);
      set(scalingGroupsAtom, currentEntry.snapshot.scalingGroups);
      set(extendedEfficacyPeriodsAtom, currentEntry.snapshot.efficacyPeriods);
    }

    return true;
  }
);
```

## Phase 2: Synchronizing with CalSen.py

### Step 4: Refactor CalSen.py to Support Matrix State

```python
# backend/API_endpoints_and_controllers/CalSenMatrix.py
"""
CalSenMatrix - Enhanced Configuration and Sensitivity Path Resolution Service
Provides comprehensive matrix-based version, zone, and efficacy period management
for sensitivity analysis configurations and financial modeling.
"""
from flask import Flask, request, jsonify
from flask_cors import CORS
import os
import logging
import json
import glob
import time
import sys
import pandas as pd

# Base directory setup
BASE_DIR = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
SCRIPT_DIR = os.path.join(BASE_DIR, 'backend')
LOGS_DIR = os.path.join(SCRIPT_DIR, 'Logs')
ORIGINAL_BASE_DIR = os.path.join(BASE_DIR, 'backend', 'Original')

# Ensure logs directory exists
os.makedirs(LOGS_DIR, exist_ok=True)

# Log file path for CalSenMatrix
CALSEN_LOG_PATH = os.path.join(LOGS_DIR, "CALSEN_MATRIX.log")

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(CALSEN_LOG_PATH),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger('calsen_matrix')
logger.info("CalSenMatrix service starting up")

# Create Flask app
app = Flask(__name__)
CORS(app)

# =====================================
# Matrix State Management
# =====================================

class MatrixStateManager:
    """Manages the matrix-based state for versions, zones, and parameters"""

    def __init__(self):
        self.state = {
            "versions": {
                "list": ["v1"],
                "active": "v1",
                "metadata": {
                    "v1": {
                        "label": "Base Case",
                        "description": "Default financial case",
                        "created": time.time(),
                        "modified": time.time()
                    }
                }
            },
            "zones": {
                "list": ["z1"],
                "active": "z1",
                "metadata": {
                    "z1": {
                        "label": "Local",
                        "description": "Local market zone",
                        "created": time.time()
                    }
                }
            },
            "parameters": {},
            "scalingGroups": [],
            "efficacyPeriods": {},
            "visualizationState": {
                "subDynamicPlots": {
                    "SP1": "off", "SP2": "off", "SP3": "off",
                    "SP4": "off", "SP5": "off", "SP6": "off",
                    "SP7": "off", "SP8": "off", "SP9": "off"
                },
                "plotTypes": {
                    "waterfall": True,
                    "bar": True,
                    "point": True
                }
            }
        }
        self.default_plant_lifetime = 20

    def get_state(self):
        """Get the current state"""
        return self.state

    def update_state(self, update_data):
        """Update the state with new data"""
        try:
            # Deep merge update_data into self.state
            self._deep_merge(self.state, update_data)
            return True, "State updated successfully"
        except Exception as e:
            logger.error(f"Error updating state: {str(e)}")
            return False, f"Error updating state: {str(e)}"

    def _deep_merge(self, target, source):
        """Recursively merge source dict into target dict"""
        for key, value in source.items():
            if key in target and isinstance(target[key], dict) and isinstance(value, dict):
                self._deep_merge(target[key], value)
            else:
                target[key] = value

    def initialize_parameter(self, param_id, param_data):
        """Initialize a parameter in the matrix state"""
        if "parameters" not in self.state:
            self.state["parameters"] = {}

        # Get plant lifetime for efficacy periods
        plant_lifetime = self.default_plant_lifetime
        if "plantLifetimeAmount10" in self.state["parameters"]:
            plant_lifetime_param = self.state["parameters"]["plantLifetimeAmount10"]
            if "matrix" in plant_lifetime_param:
                active_version = self.state["versions"]["active"]
                active_zone = self.state["zones"]["active"]
                if active_version in plant_lifetime_param["matrix"] and active_zone in plant_lifetime_param["matrix"][active_version]:
                    plant_lifetime = plant_lifetime_param["matrix"][active_version][active_zone]

        # If parameter already exists, just update specific fields
        if param_id in self.state["parameters"]:
            param = self.state["parameters"][param_id]

            # Update fields from param_data
            for key, value in param_data.items():
                if key != "matrix" and key != "inheritance":
                    param[key] = value

            # Update default values for versions and zones
            for version_id in self.state["versions"]["list"]:
                if version_id not in param["versions"]:
                    param["versions"][version_id] = {
                        "label": self.state["versions"]["metadata"][version_id]["label"],
                        "isActive": version_id == self.state["versions"]["active"]
                    }

                if version_id not in param["inheritance"]:
                    param["inheritance"][version_id] = {
                        "source": None,
                        "percentage": 100
                    }

                if version_id not in param["matrix"]:
                    param["matrix"][version_id] = {}

                for zone_id in self.state["zones"]["list"]:
                    if zone_id not in param["zones"]:
                        param["zones"][zone_id] = {
                            "label": self.state["zones"]["metadata"][zone_id]["label"],
                            "isActive": zone_id == self.state["zones"]["active"]
                        }

                    if zone_id not in param["matrix"][version_id]:
                        # Use default value if available
                        default_value = param_data.get("value", 0)
                        param["matrix"][version_id][zone_id] = default_value
        else:
            # Create new parameter entry
            default_value = param_data.get("value", 0)

            param = {
                "id": param_id,
                "label": param_data.get("label", param_id),
                "type": param_data.get("type", "number"),
                "versions": {},
                "zones": {},
                "matrix": {},
                "inheritance": {},
                "dynamicAppendix": param_data.get("dynamicAppendix", {
                    "scaling": {
                        "type": None,
                        "factor": 1,
                        "operation": "multiply",
                        "enabled": False,
                        "baseValue": default_value,
                        "scaledValue": default_value,
                        "notes": ""
                    },
                    "group": { "id": None, "name": None, "isProtected": False },
                    "itemState": {
                        "vKey": param_id.startswith("vAmount") and f"V{param_id.replace('vAmount', '')}" or None,
                        "rKey": param_id.startswith("rAmount") and f"R{param_id.replace('rAmount', '')}" or None,
                        "fKey": param_id.startswith("Amount") and param_id.replace("Amount", "").isdigit() and
                               34 <= int(param_id.replace("Amount", "")) <= 38 and
                               f"F{int(param_id.replace('Amount', '')) - 33}" or None,
                        "rfKey": param_id.startswith("Amount") and param_id.replace("Amount", "").isdigit() and
                                80 <= int(param_id.replace("Amount", "")) <= 84 and
                                f"RF{int(param_id.replace('Amount', '')) - 79}" or None,
                        "sKey": param_id.startswith("Amount") and param_id.replace("Amount", "").isdigit() and
                               f"S{param_id.replace('Amount', '')}" or None,
                        "status": "off"
                    }
                }),
                "efficacyPeriod": param_data.get("efficacyPeriod", {
                    "start": { "value": 0 },
                    "end": { "value": plant_lifetime }
                })
            }

            # Initialize for all versions and zones
            for version_id in self.state["versions"]["list"]:
                param["versions"][version_id] = {
                    "label": self.state["versions"]["metadata"][version_id]["label"],
                    "isActive": version_id == self.state["versions"]["active"]
                }

                param["inheritance"][version_id] = {
                    "source": None,
                    "percentage": 100
                }

                param["matrix"][version_id] = {}

                for zone_id in self.state["zones"]["list"]:
                    param["zones"][zone_id] = {
                        "label": self.state["zones"]["metadata"][zone_id]["label"],
                        "isActive": zone_id == self.state["zones"]["active"]
                    }

                    param["matrix"][version_id][zone_id] = default_value

            self.state["parameters"][param_id] = param

        return param

    def get_parameter_value(self, param_id, version_id=None, zone_id=None):
        """Get parameter value for the specified version and zone"""
        if param_id not in self.state["parameters"]:
            return None

        param = self.state["parameters"][param_id]

        # Use active version/zone if not specified
        version = version_id or self.state["versions"]["active"]
        zone = zone_id or self.state["zones"]["active"]

        # Check if version and zone exist in the matrix
        if version not in param["matrix"] or zone not in param["matrix"][version]:
            return None

        return param["matrix"][version][zone]

    def update_parameter_value(self, param_id, value, version_id=None, zone_id=None):
        """Update parameter value for the specified version and zone"""
        if param_id not in self.state["parameters"]:
            return False, f"Parameter {param_id} not found"

        param = self.state["parameters"][param_id]

        # Use active version/zone if not specified
        version = version_id or self.state["versions"]["active"]
        zone = zone_id or self.state["zones"]["active"]

        # Check if version and zone exist
        if version not in param["matrix"]:
            param["matrix"][version] = {}

        if zone not in param["matrix"][version]:
            param["matrix"][version][zone] = 0

        # Update the value
        param["matrix"][version][zone] = value

        # Apply inheritance to other versions
        for v in self.state["versions"]["list"]:
            if v != version and "inheritance" in param and v in param["inheritance"]:
                inheritance = param["inheritance"][v]
                if inheritance["source"] == version and inheritance["percentage"] < 100:
                    # Calculate inherited value
                    source_value = value
                    current_value = param["matrix"][v][zone] if zone in param["matrix"][v] else 0
                    inherit_percent = inheritance["percentage"] / 100

                    # inherited value = (current * (1 - inherit%)) + (source * inherit%)
                    new_value = (current_value * (1 - inherit_percent)) + (source_value * inherit_percent)
                    param["matrix"][v][zone] = new_value

        return True, f"Parameter {param_id} updated successfully"

    def update_efficacy_period(self, param_id, start, end, version_id=None, zone_id=None):
        """Update efficacy period for a parameter"""
        if param_id not in self.state["parameters"]:
            return False, f"Parameter {param_id} not found"

        param = self.state["parameters"][param_id]

        # Get plant lifetime for validating efficacy periods
        plant_lifetime = self.default_plant_lifetime
        if "plantLifetimeAmount10" in self.state["parameters"]:
            plant_lifetime_param = self.state["parameters"]["plantLifetimeAmount10"]
            if "matrix" in plant_lifetime_param:
                active_version = self.state["versions"]["active"]
                active_zone = self.state["zones"]["active"]
                if active_version in plant_lifetime_param["matrix"] and active_zone in plant_lifetime_param["matrix"][active_version]:
                    plant_lifetime = plant_lifetime_param["matrix"][active_version][active_zone]

        # Validate start and end values
        start = max(0, min(start, end, plant_lifetime))
        end = max(start, min(end, plant_lifetime))

        # Update efficacy period
        if "efficacyPeriod" not in param:
            param["efficacyPeriod"] = {
                "start": { "value": start },
                "end": { "value": end }
            }
        else:
            param["efficacyPeriod"]["start"]["value"] = start
            param["efficacyPeriod"]["end"]["value"] = end

        # Update scaling item efficacy if this is a form value that appears in scaling groups
        self._synchronize_scaling_item_efficacy(param_id, start, end)

        return True, f"Efficacy period for {param_id} updated successfully"

    def _synchronize_scaling_item_efficacy(self, param_id, start, end):
        """Synchronize efficacy period between form values and scaling items"""
        # Check if this parameter exists in any scaling group
        found = False

        for group in self.state.get("scalingGroups", []):
            for item in group.get("items", []):
                if item.get("id") == param_id:
                    found = True

                    # Update efficacy period for this scaling item
                    item_key = f"item_{param_id}"
                    if "efficacyPeriods" not in self.state:
                        self.state["efficacyPeriods"] = {}

                    plant_lifetime = self.default_plant_lifetime
                    if "plantLifetimeAmount10" in self.state["parameters"]:
                        plant_lifetime_param = self.state["parameters"]["plantLifetimeAmount10"]
                        active_version = self.state["versions"]["active"]
                        active_zone = self.state["zones"]["active"]
                        if active_version in plant_lifetime_param["matrix"] and active_zone in plant_lifetime_param["matrix"][active_version]:
                            plant_lifetime = plant_lifetime_param["matrix"][active_version][active_zone]

                    if item_key not in self.state["efficacyPeriods"]:
                        self.state["efficacyPeriods"][item_key] = {
                            "type": "item",
                            "id": param_id,
                            "groupId": group.get("id"),
                            "start": start,
                            "end": end,
                            "isCustomized": start > 0 or end < plant_lifetime,
                            "priority": "item",
                            "formValueRef": param_id
                        }
                    else:
                        self.state["efficacyPeriods"][item_key]["start"] = start
                        self.state["efficacyPeriods"][item_key]["end"] = end
                        self.state["efficacyPeriods"][item_key]["isCustomized"] = start > 0 or end < plant_lifetime

        return found

    def create_version(self, label, description=None, base_version=None):
        """Create a new version, optionally inheriting from a base version"""
        # Generate version ID
        version_id = f"v{len(self.state['versions']['list']) + 1}"

        # Add to versions list
        self.state["versions"]["list"].append(version_id)

        # Add version metadata
        self.state["versions"]["metadata"][version_id] = {
            "label": label,
            "description": description or f"Version created on {time.strftime('%Y-%m-%d %H:%M:%S')}",
            "created": time.time(),
            "modified": time.time(),
            "baseVersion": base_version
        }

        # Initialize matrix values for all parameters
        for param_id, param in self.state["parameters"].items():
            # Add version to parameter versions
            param["versions"][version_id] = {
                "label": label,
                "isActive": False
            }

            # Initialize matrix for this version
            param["matrix"][version_id] = {}

            # Set inheritance from base version if provided
            if base_version:
                param["inheritance"][version_id] = {
                    "source": base_version,
                    "percentage": 70  # Default to 70% inheritance
                }

                # Copy values from base version with 70% inheritance
                for zone_id in self.state["zones"]["list"]:
                    if base_version in param["matrix"] and zone_id in param["matrix"][base_version]:
                        base_value = param["matrix"][base_version][zone_id]
                        param["matrix"][version_id][zone_id] = base_value
            else:
                param["inheritance"][version_id] = {
                    "source": None,
                    "percentage": 100  # No inheritance
                }

                # Initialize with default values
                for zone_id in self.state["zones"]["list"]:
                    param["matrix"][version_id][zone_id] = 0

        return version_id, "Version created successfully"

    def create_zone(self, label, description=None):
        """Create a new zone"""
        # Generate zone ID
        zone_id = f"z{len(self.state['zones']['list']) + 1}"

        # Add to zones list
        self.state["zones"]["list"].append(zone_id)

        # Add zone metadata
        self.state["zones"]["metadata"][zone_id] = {
            "label": label,
            "description": description or f"Zone created on {time.strftime('%Y-%m-%d %H:%M:%S')}",
            "created": time.time()
        }

        # Initialize matrix values for all parameters
        for param_id, param in self.state["parameters"].items():
            # Add zone to parameter zones
            param["zones"][zone_id] = {
                "label": label,
                "isActive": False
            }

            # Initialize matrix for this zone
            for version_id in self.state["versions"]["list"]:
                if version_id in param["matrix"]:
                    # For new zone, use value from first existing zone as default
                    first_zone = next(iter(param["matrix"][version_id]))
                    default_value = param["matrix"][version_id][first_zone]
                    param["matrix"][version_id][zone_id] = default_value

        return zone_id, "Zone created successfully"

    def get_scaling_groups(self):
        """Get all scaling groups"""
        return self.state.get("scalingGroups", [])

    def update_scaling_groups(self, scaling_groups):
        """Update scaling groups"""
        # Update scaling groups in state
        self.state["scalingGroups"] = scaling_groups

        # Synchronize efficacy periods with form values
        for group in scaling_groups:
            # Group level efficacy
            group_key = f"group_{group['id']}"
            if "efficacyPeriods" not in self.state:
                self.state["efficacyPeriods"] = {}

            plant_lifetime = self.default_plant_lifetime
            if "plantLifetimeAmount10" in self.state["parameters"]:
                plant_lifetime_param = self.state["parameters"]["plantLifetimeAmount10"]
                active_version = self.state["versions"]["active"]
                active_zone = self.state["zones"]["active"]
                if active_version in plant_lifetime_param["matrix"] and active_zone in plant_lifetime_param["matrix"][active_version]:
                    plant_lifetime = plant_lifetime_param["matrix"][active_version][active_zone]

            if group_key not in self.state["efficacyPeriods"]:
                self.state["efficacyPeriods"][group_key] = {
                    "type": "group",
                    "id": group["id"],
                    "name": group["name"],
                    "start": 0,
                    "end": plant_lifetime,
                    "isCustomized": False,
                    "overridesItems": False
                }

            # Item level efficacy - sync with form values
            for item in group.get("items", []):
                item_id = item.get("id")

                # Skip items without ID
                if not item_id:
                    continue

                # Check if corresponding form value exists
                if item_id in self.state["parameters"]:
                    form_item = self.state["parameters"][item_id]
                    if "efficacyPeriod" in form_item:
                        # Sync form value efficacy to scaling item
                        item_key = f"item_{item_id}"
                        if item_key not in self.state["efficacyPeriods"]:
                            self.state["efficacyPeriods"][item_key] = {
                                "type": "item",
                                "id": item_id,
                                "groupId": group["id"],
                                "start": form_item["efficacyPeriod"]["start"]["value"],
                                "end": form_item["efficacyPeriod"]["end"]["value"],
                                "isCustomized": form_item["efficacyPeriod"]["start"]["value"] > 0 or
                                                form_item["efficacyPeriod"]["end"]["value"] < plant_lifetime,
                                "priority": "item",
                                "formValueRef": item_id
                            }
                        else:
                            # Update existing efficacy period
                            self.state["efficacyPeriods"][item_key]["start"] = form_item["efficacyPeriod"]["start"]["value"]
                            self.state["efficacyPeriods"][item_key]["end"] = form_item["efficacyPeriod"]["end"]["value"]
                            self.state["efficacyPeriods"][item_key]["isCustomized"] = form_item["efficacyPeriod"]["start"]["value"] > 0 or form_item["efficacyPeriod"]["end"]["value"] < plant_lifetime
                            self.state["efficacyPeriods"][item_key]["groupId"] = group["id"]

        return True, "Scaling groups updated successfully"

    def update_run_options(self, run_options):
        """Update run options"""
        if "runOptions" not in self.state:
            self.state["runOptions"] = {}

        # Update run options
        self.state["runOptions"].update(run_options)
        return True, "Run options updated successfully"

    def update_visualization_state(self, visualization_state):
        """Update visualization state"""
        if "visualizationState" not in self.state:
            self.state["visualizationState"] = {
                "subDynamicPlots": {
                    "SP1": "off", "SP2": "off", "SP3": "off",
                    "SP4": "off", "SP5": "off", "SP6": "off",
                    "SP7": "off", "SP8": "off", "SP9": "off"
                },
                "plotTypes": {
                    "waterfall": True,
                    "bar": True,
                    "point": True
                }
            }

        # Update subDynamicPlots if provided
        if "subDynamicPlots" in visualization_state:
            self.state["visualizationState"]["subDynamicPlots"].update(visualization_state["subDynamicPlots"])

        # Update plotTypes if provided
        if "plotTypes" in visualization_state:
            self.state["visualizationState"]["plotTypes"].update(visualization_state["plotTypes"])

        return True, "Visualization state updated successfully"

    def export_paths_for_calculation(self, version):
        """
        Export paths and configuration for calculation engine.
        This creates a structure compatible with the expected format for CFA.
        """
        # Base paths
        base_dir = os.path.join(BASE_DIR, 'backend', 'Original')
        version_str = str(version)
        results_folder = os.path.join(base_dir, f'Batch({version_str})', f'Results({version_str})')
        sensitivity_dir = os.path.join(results_folder, 'Sensitivity')

        # Ensure directories exist
        os.makedirs(sensitivity_dir, exist_ok=True)

        # Get active version and zone
        active_version = self.state["versions"]["active"]
        active_zone = self.state["zones"]["active"]

        # Get run options
        run_options = self.state.get("runOptions", {
            "useSummaryItems": True,
            "includeRemarks": False,
            "includeCustomFeatures": False
        })

        # Prepare path sets for all parameters
        path_sets = {}

        # Convert parameters to the expected format
        for param_id, param in self.state["parameters"].items():
            # Skip parameters that don't start with S
            if not param.get("dynamicAppendix", {}).get("itemState", {}).get("sKey", "").startswith("S"):
                continue

            s_param = param.get("dynamicAppendix", {}).get("itemState", {}).get("sKey")
            if not s_param:
                continue

            # Check if parameter is enabled
            if param.get("dynamicAppendix", {}).get("scaling", {}).get("enabled", False):
                # Get mode and determine variation format
                mode = param.get("dynamicAppendix", {}).get("scaling", {}).get("type", "percentage").lower()

                # Use scaled value as variation
                scaled_value = param.get("dynamicAppendix", {}).get("scaling", {}).get("scaledValue")
                base_value = param.get("dynamicAppendix", {}).get("scaling", {}).get("baseValue", 0)

                # Calculate variation percentage
                if mode == "percentage" and base_value != 0:
                    variation = ((scaled_value / base_value) - 1) * 100
                else:
                    variation = scaled_value - base_value

                # Format variation string
                var_str = f"{variation:+.2f}"

                # Build paths for this variation
                Econ_var_dir = os.path.join(
                    base_dir,
                    f"Batch({version_str})",
                    f"Results({version_str})",
                    "Sensitivity",
                    s_param,
                    mode,
                    "Configuration",
                    f"{s_param}_{var_str}"
                )

                # Parameter variation directory
                param_var_dir = os.path.join(
                    base_dir,
                    f"Batch({version_str})",
                    f"Results({version_str})",
                    "Sensitivity",
                    s_param,
                    mode,
                    var_str
                )

                # Mode directory mapping
                mode_dir_mapping = {
                    'percentage': 'Percentage',
                    'directvalue': 'DirectValue',
                    'absolutedeparture': 'AbsoluteDeparture',
                    'montecarlo': 'MonteCarlo'
                }
                mode_dir_name = mode_dir_mapping.get(mode, 'Percentage')

                # Configuration directory
                config_var_dir = os.path.join(
                    base_dir,
                    f"Batch({version_str})",
                    f"Results({version_str})",
                    "Sensitivity",
                    mode_dir_name,
                    "Configuration",
                    f"{s_param}_{var_str}"
                )

                # Configuration matrix file
                config_matrix_file = os.path.join(
                    param_var_dir,
                    f"General_Configuration_Matrix({version_str}).csv"
                )

                # Check for alternate locations if needed
                if not os.path.exists(config_matrix_file):
                    alt_config_matrix_file = os.path.join(
                        base_dir,
                        f"Batch({version_str})",
                        f"Results({version_str})",
                        f"General_Configuration_Matrix({version_str}).csv"
                    )
                    if os.path.exists(alt_config_matrix_file):
                        config_matrix_file = alt_config_matrix_file

                # Configuration file
                config_file = os.path.join(
                    base_dir,
                    f"Batch({version_str})",
                    f"ConfigurationPlotSpec({version_str})",
                    f"configurations({version_str}).py"
                )

                # Create directories if they don't exist
                os.makedirs(param_var_dir, exist_ok=True)
                os.makedirs(config_var_dir, exist_ok=True)

                # Add paths for this variation
                if s_param not in path_sets:
                    path_sets[s_param] = {
                        "mode": mode,
                        "variations": {},
                        "compareToKey": param.get("dynamicAppendix", {}).get("group", {}).get("compareToKey", "S13"),
                        "comparisonType": param.get("dynamicAppendix", {}).get("group", {}).get("comparisonType", "primary")
                    }

                path_sets[s_param]["variations"][var_str] = {
                    "param_var_dir": param_var_dir,
                    "config_var_dir": config_var_dir,
                    "config_matrix_file": config_matrix_file,
                    "config_file": config_file,
                    "Econ_var_dir": Econ_var_dir,
                    "mode": mode,
                    "variation": variation,
                    "variation_str": var_str
                }

        # Create a matrix-based configuration export
        matrix_config = {
            "versions": self.state["versions"],
            "zones": self.state["zones"],
            "activeVersion": active_version,
            "activeZone": active_zone,
            "runOptions": run_options,
            "efficacyPeriods": self.state["efficacyPeriods"],
            "visualizationState": self.state["visualizationState"]
        }

        # Save matrix configuration
        os.makedirs(os.path.join(sensitivity_dir, "Reports"), exist_ok=True)
        matrix_config_file = os.path.join(sensitivity_dir, "Reports", "matrix_config.json")
        with open(matrix_config_file, 'w') as f:
            json.dump(matrix_config, f, indent=2)

        # Create path configuration compatible with CFA
        calsen_paths = {
            "version": version,
            "path_sets": path_sets,
            "matrix_config": matrix_config_file
        }

        # Save calsen paths for CFA
        calsen_paths_file = os.path.join(sensitivity_dir, "Reports", "calsen_paths.json")
        with open(calsen_paths_file, 'w') as f:
            json.dump(calsen_paths, f, indent=2)

        return calsen_paths

# Initialize the matrix state manager
matrix_state_manager = MatrixStateManager()

# =====================================
# API Endpoints
# =====================================

@app.route('/health', methods=['GET'])
def health_check():
    """Health check endpoint"""
    return jsonify({
        "status": "healthy",
        "service": "CalSenMatrix",
        "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
        "versions": len(matrix_state_manager.state["versions"]["list"]),
        "zones": len(matrix_state_manager.state["zones"]["list"]),
        "parameters": len(matrix_state_manager.state["parameters"])
    })

@app.route('/get_state', methods=['GET'])
def get_state():
    """Get the current matrix state"""
    return jsonify(matrix_state_manager.get_state())

@app.route('/update_state', methods=['POST'])
def update_state():
    """Update the matrix state"""
    data = request.json
    if not data:
        return jsonify({"error": "No data provided"}), 400

    success, message = matrix_state_manager.update_state(data)
    if success:
        return jsonify({"status": "success", "message": message})
    else:
        return jsonify({"error": message}), 500

@app.route('/initialize_parameter', methods=['POST'])
def initialize_parameter():
    """Initialize a parameter in the matrix state"""
    data = request.json
    if not data or 'param_id' not in data:
        return jsonify({"error": "Parameter ID is required"}), 400

    param_id = data['param_id']
    param_data = data.get('param_data', {})

    param = matrix_state_manager.initialize_parameter(param_id, param_data)
    return jsonify({
        "status": "success",
        "message": f"Parameter {param_id} initialized successfully",
        "parameter": param
    })

@app.route('/get_parameter_value', methods=['GET'])
def get_parameter_value():
    """Get parameter value for the specified version and zone"""
    param_id = request.args.get('param_id')
    version_id = request.args.get('version_id')
    zone_id = request.args.get('zone_id')

    if not param_id:
        return jsonify({"error": "Parameter ID is required"}), 400

    value = matrix_state_manager.get_parameter_value(param_id, version_id, zone_id)
    if value is None:
        return jsonify({"error": f"Parameter {param_id} not found"}), 404

    return jsonify({
        "status": "success",
        "param_id": param_id,
        "version_id": version_id or matrix_state_manager.state["versions"]["active"],
        "zone_id": zone_id or matrix_state_manager.state["zones"]["active"],
        "value": value
    })

@app.route('/update_parameter_value', methods=['POST'])
def update_parameter_value():
    """Update parameter value for the specified version and zone"""
    data = request.json
    if not data or 'param_id' not in data or 'value' not in data:
        return jsonify({"error": "Parameter ID and value are required"}), 400

    param_id = data['param_id']
    value = data['value']
    version_id = data.get('version_id')
    zone_id = data.get('zone_id')

    success, message = matrix_state_manager.update_parameter_value(param_id, value, version_id, zone_id)
    if success:
        return jsonify({"status": "success", "message": message})
    else:
        return jsonify({"error": message}), 404

@app.route('/update_efficacy_period', methods=['POST'])
def update_efficacy_period():
    """Update efficacy period for a parameter"""
    data = request.json
    if not data or 'param_id' not in data or 'start' not in data or 'end' not in data:
        return jsonify({"error": "Parameter ID, start, and end are required"}), 400

    param_id = data['param_id']
    start = data['start']
    end = data['end']
    version_id = data.get('version_id')
    zone_id = data.get('zone_id')

    success, message = matrix_state_manager.update_efficacy_period(param_id, start, end, version_id, zone_id)
    if success:
        return jsonify({"status": "success", "message": message})
    else:
        return jsonify({"error": message}), 404

@app.route('/create_version', methods=['POST'])
def create_version():
    """Create a new version"""
    data = request.json
    if not data or 'label' not in data:
        return jsonify({"error": "Version label is required"}), 400

    label = data['label']
    description = data.get('description')
    base_version = data.get('base_version')

    version_id, message = matrix_state_manager.create_version(label, description, base_version)
    return jsonify({
        "status": "success",
        "message": message,
        "version_id": version_id
    })

@app.route('/create_zone', methods=['POST'])
def create_zone():
    """Create a new zone"""
    data = request.json
    if not data or 'label' not in data:
        return jsonify({"error": "Zone label is required"}), 400

    label = data['label']
    description = data.get('description')

    zone_id, message = matrix_state_manager.create_zone(label, description)
    return jsonify({
        "status": "success",
        "message": message,
        "zone_id": zone_id
    })

@app.route('/get_scaling_groups', methods=['GET'])
def get_scaling_groups():
    """Get all scaling groups"""
    return jsonify({
        "status": "success",
        "scaling_groups": matrix_state_manager.get_scaling_groups()
    })

@app.route('/update_scaling_groups', methods=['POST'])
def update_scaling_groups():
    """Update scaling groups"""
    data = request.json
    if not data or 'scaling_groups' not in data:
        return jsonify({"error": "Scaling groups are required"}), 400

    scaling_groups = data['scaling_groups']

    success, message = matrix_state_manager.update_scaling_groups(scaling_groups)
    if success:
        return jsonify({"status": "success", "message": message})
    else:
        return jsonify({"error": message}), 500

@app.route('/update_run_options', methods=['POST'])
def update_run_options():
    """Update run options"""
    data = request.json
    if not data:
        return jsonify({"error": "Run options are required"}), 400

    success, message = matrix_state_manager.update_run_options(data)
    if success:
        return jsonify({"status": "success", "message": message})
    else:
        return jsonify({"error": message}), 500

@app.route('/update_visualization_state', methods=['POST'])
def update_visualization_state():
    """Update visualization state"""
    data = request.json
    if not data:
        return jsonify({"error": "Visualization state is required"}), 400

    success, message = matrix_state_manager.update_visualization_state(data)
    if success:
        return jsonify({"status": "success", "message": message})
    else:
        return jsonify({"error": message}), 500

@app.route('/export_paths_for_calculation', methods=['POST'])
def export_paths_for_calculation():
    """Export paths and configuration for calculation engine"""
    data = request.json
    if not data or 'version' not in data:
        return jsonify({"error": "Version is required"}), 400

    version = data['version']

    paths = matrix_state_manager.export_paths_for_calculation(version)
    return jsonify({
        "status": "success",
        "message": "Paths exported successfully",
        "paths": paths
    })

@app.route('/synchronize_form_matrix', methods=['POST'])
def synchronize_form_matrix():
    """
    Synchronize the matrix state with the form values from the front-end.
    This endpoint accepts the complete form values state and updates the matrix accordingly.
    """
    data = request.json
    if not data or 'formValues' not in data:
        return jsonify({"error": "Form values are required"}), 400

    form_values = data['formValues']
    version_id = data.get('version_id') or matrix_state_manager.state["versions"]["active"]
    zone_id = data.get('zone_id') or matrix_state_manager.state["zones"]["active"]

    # Update parameters in the matrix state
    updated_params = []
    for param_id, param_data in form_values.items():
        # Initialize or update parameter
        matrix_state_manager.initialize_parameter(param_id, param_data)

        # Update parameter value
        if 'value' in param_data:
            success, _ = matrix_state_manager.update_parameter_value(
                param_id, param_data['value'], version_id, zone_id
            )
            if success:
                updated_params.append(param_id)

        # Update efficacy period if present
        if 'efficacyPeriod' in param_data:
            if 'start' in param_data['efficacyPeriod'] and 'end' in param_data['efficacyPeriod']:
                start_value = param_data['efficacyPeriod']['start'].get('value', 0)
                end_value = param_data['efficacyPeriod']['end'].get('value', 20)

                matrix_state_manager.update_efficacy_period(
                    param_id, start_value, end_value, version_id, zone_id
                )

    # Update scaling groups if present
    if 'scalingGroups' in data:
        matrix_state_manager.update_scaling_groups(data['scalingGroups'])

    # Update run options if present
    if 'runOptions' in data:
        matrix_state_manager.update_run_options(data['runOptions'])

    # Update visualization state if present
    if 'visualizationState' in data:
        matrix_state_manager.update_visualization_state(data['visualizationState'])

    return jsonify({
        "status": "success",
        "message": f"Synchronized {len(updated_params)} parameters",
        "updated_params": updated_params
    })

# =====================================
# Extended API for CFA Integration
# =====================================

@app.route('/generate_config_matrix', methods=['POST'])
def generate_config_matrix():
    """
    Generate configuration matrix CSV file based on efficacy periods.
    This creates a matrix showing which parameters are active in which time periods.
    """
    data = request.json
    if not data or 'version' not in data:
        return jsonify({"error": "Version is required"}), 400

    version = data['version']
    version_str = str(version)

    try:
        # Get parameters with efficacy periods
        parameters = []
        for param_id, param in matrix_state_manager.state["parameters"].items():
            if "efficacyPeriod" in param:
                parameters.append({
                    "id": param_id,
                    "label": param.get("label", param_id),
                    "start": param["efficacyPeriod"]["start"]["value"],
                    "end": param["efficacyPeriod"]["end"]["value"]
                })

        # Get plant lifetime
        plant_lifetime = 20  # Default
        if "plantLifetimeAmount10" in matrix_state_manager.state["parameters"]:
            plant_lifetime_param = matrix_state_manager.state["parameters"]["plantLifetimeAmount10"]
            active_version = matrix_state_manager.state["versions"]["active"]
            active_zone = matrix_state_manager.state["zones"]["active"]
            if active_version in plant_lifetime_param["matrix"] and active_zone in plant_lifetime_param["matrix"][active_version]:
                plant_lifetime = plant_lifetime_param["matrix"][active_version][active_zone]

        # Create a matrix of time periods
        time_periods = []

        # Find unique start and end points
        break_points = set()
        for param in parameters:
            if param["start"] > 0:
                break_points.add(param["start"])
            if param["end"] < plant_lifetime:
                break_points.add(param["end"] + 1)  # Add +1 because end is inclusive

        # Add start and end points
        break_points.add(0)
        break_points.add(plant_lifetime)

        # Sort break points
        sorted_breaks = sorted(break_points)

        # Create time periods
        for i in range(len(sorted_breaks) - 1):
            start = sorted_breaks[i]
            end = sorted_breaks[i+1] - 1  # -1 because end is inclusive

            # Skip invalid periods
            if start > end:
                continue

            time_periods.append({
                "start": start,
                "end": end,
                "length": end - start + 1
            })

        # Create matrix data
        matrix_data = []
        for period in time_periods:
            row = {
                "start": period["start"],
                "end": period["end"],
                "length": period["length"]
            }

            # For each parameter, check if it's active during this period
            for param in parameters:
                param_id = param["id"]
                is_active = period["start"] >= param["start"] and period["end"] <= param["end"]
                row[param_id] = 1 if is_active else 0

            matrix_data.append(row)

        # Convert to DataFrame
        df = pd.DataFrame(matrix_data)

        # Save to CSV
        base_dir = os.path.join(BASE_DIR, 'backend', 'Original')
        results_folder = os.path.join(base_dir, f'Batch({version_str})', f'Results({version_str})')
        os.makedirs(results_folder, exist_ok=True)

        csv_path = os.path.join(results_folder, f"General_Configuration_Matrix({version_str}).csv")
        df.to_csv(csv_path, index=False)

        return jsonify({
            "status": "success",
            "message": "Configuration matrix generated successfully",
            "path": csv_path,
            "rows": len(matrix_data),
            "periods": len(time_periods)
        })

    except Exception as e:
        logger.error(f"Error generating configuration matrix: {str(e)}")
        return jsonify({
            "error": f"Error generating configuration matrix: {str(e)}"
        }), 500

# =====================================
# Main Application
# =====================================

if __name__ == '__main__':
    # Get port from command line arguments or use default
    port = int(sys.argv[1]) if len(sys.argv) > 1 else 2750

    logger.info(f"Starting CalSenMatrix service on port {port}")
    app.run(debug=False, host='0.0.0.0', port=port)
```

### Step 5: Create Jotai-CalSen Synchronization Service

```javascript
// src/services/calsenSyncService.js
import axios from 'axios';

// CalSen service base URL
const CALSEN_BASE_URL = 'http://localhost:2750';

// Create axios instance for CalSen API
const calsenApi = axios.create({
  baseURL: CALSEN_BASE_URL,
  timeout: 30000, // 30 second timeout
  headers: {
    'Content-Type': 'application/json'
  }
});

/**
 * Synchronize Jotai state with CalSen service
 * @param {Object} state Complete application state object
 * @returns {Promise<Object>} Synchronization result
 */
export const synchronizeWithCalSen = async (state) => {
  try {
    // Format state for CalSen
    const formattedState = {
      formValues: state.formValues,
      scalingGroups: state.scalingGroups,
      runOptions: state.runOptions,
      visualizationState: {
        subDynamicPlots: state.subDynamicPlots,
        plotTypes: {
          waterfall: state.S && Object.values(state.S).some(s => s.waterfall),
          bar: state.S && Object.values(state.S).some(s => s.bar),
          point: state.S && Object.values(state.S).some(s => s.point)
        }
      }
    };

    // Synchronize form matrix
    const response = await calsenApi.post('/synchronize_form_matrix', formattedState);

    return {
      success: true,
      message: 'Synchronized with CalSen successfully',
      result: response.data
    };
  } catch (error) {
    console.error('Error synchronizing with CalSen:', error);
    return {
      success: false,
      message: `Error synchronizing with CalSen: ${error.message}`,
      error
    };
  }
};

/**
 * Generate config matrix CSV based on efficacy periods
 * @param {number} version Version number
 * @returns {Promise<Object>} Generation result
 */
export const generateConfigMatrix = async (version) => {
  try {
    const response = await calsenApi.post('/generate_config_matrix', { version });

    return {
      success: true,
      message: 'Configuration matrix generated successfully',
      result: response.data
    };
  } catch (error) {
    console.error('Error generating config matrix:', error);
    return {
      success: false,
      message: `Error generating config matrix: ${error.message}`,
      error
    };
  }
};

/**
 * Export paths for CFA calculation
 * @param {number} version Version number
 * @returns {Promise<Object>} Export result
 */
export const exportPathsForCalculation = async (version) => {
  try {
    const response = await calsenApi.post('/export_paths_for_calculation', { version });

    return {
      success: true,
      message: 'Paths exported successfully',
      paths: response.data.paths
    };
  } catch (error) {
    console.error('Error exporting paths:', error);
    return {
      success: false,
      message: `Error exporting paths: ${error.message}`,
      error
    };
  }
};

/**
 * Check CalSen health
 * @returns {Promise<Object>} Health status
 */
export const checkCalSenHealth = async () => {
  try {
    const response = await calsenApi.get('/health');

    return {
      success: true,
      healthy: response.data.status === 'healthy',
      status: response.data
    };
  } catch (error) {
    console.error('Error checking CalSen health:', error);
    return {
      success: false,
      healthy: false,
      message: `Error checking CalSen health: ${error.message}`,
      error
    };
  }
};

export default {
  synchronizeWithCalSen,
  generateConfigMatrix,
  exportPathsForCalculation,
  checkCalSenHealth
};
```

## Phase 3: User Interface Components

### Step 6: Create Matrix Editing Dialog Component

```javascript
// src/components/MatrixEditDialog.js
import React, { useState, useEffect } from 'react';
import { useAtom } from 'jotai';
import {
  formValuesMatrixAtom,
  versionsAtom,
  zonesAtom,
  updateMatrixValueAtom
} from '../atoms/matrixFormValues';
import { addHistoryEntryAtom } from '../atoms/matrixHistory';

const MatrixEditDialog = ({ paramId, onClose }) => {
  const [formMatrix] = useAtom(formValuesMatrixAtom);
  const [versions] = useAtom(versionsAtom);
  const [zones] = useAtom(zonesAtom);
  const [, updateMatrixValue] = useAtom(updateMatrixValueAtom);
  const [, addHistoryEntry] = useAtom(addHistoryEntryAtom);

  const [selectedVersion, setSelectedVersion] = useState(versions.active);
  const [selectedZone, setSelectedZone] = useState(zones.active);
  const [currentValue, setCurrentValue] = useState('');
  const [editMode, setEditMode] = useState(false);

  // Get parameter from form matrix
  const parameter = formMatrix[paramId];

  // Initialize current value based on selected version and zone
  useEffect(() => {
    if (parameter &&
        parameter.matrix[selectedVersion] &&
        parameter.matrix[selectedVersion][selectedZone] !== undefined) {
      setCurrentValue(parameter.matrix[selectedVersion][selectedZone]);
    } else {
      setCurrentValue('');
    }
  }, [parameter, selectedVersion, selectedZone]);

  // Handle value change
  const handleValueChange = (e) => {
    const val = e.target.value;
    if (parameter.type === 'number') {
      // Allow empty string or valid number
      if (val === '' || !isNaN(parseFloat(val))) {
        setCurrentValue(val);
      }
    } else {
      setCurrentValue(val);
    }
  };

  // Handle save
  const handleSave = () => {
    // Convert to number if parameter type is number
    const valueToSave = parameter.type === 'number' && currentValue !== ''
      ? parseFloat(currentValue)
      : currentValue;

    // Update matrix value
    updateMatrixValue({
      paramId,
      versionId: selectedVersion,
      zoneId: selectedZone,
      value: valueToSave
    });

    // Add to history
    addHistoryEntry({
      action: 'update_matrix_value',
      description: `Updated ${parameter.label} value for version ${selectedVersion}, zone ${selectedZone}`
    });

    // Exit edit mode
    setEditMode(false);
  };

  // Get inheritance information
  const getInheritanceInfo = () => {
    if (!parameter.inheritance[selectedVersion]) {
      return null;
    }

    const inheritance = parameter.inheritance[selectedVersion];
    if (!inheritance.source) {
      return null;
    }

    const sourceVersion = inheritance.source;
    const sourceVersionLabel = versions.metadata[sourceVersion]?.label || sourceVersion;

    return {
      source: sourceVersion,
      sourceLabel: sourceVersionLabel,
      percentage: inheritance.percentage
    };
  };

  if (!parameter) {
    return <div className="error">Parameter not found</div>;
  }

  const inheritanceInfo = getInheritanceInfo();

  return (
    <div className="matrix-edit-dialog">
      <div className="dialog-header">
        <h2>Edit Matrix Values: {parameter.label}</h2>
        <button className="close-button" onClick={onClose}></button>
      </div>

      <div className="dialog-content">
        <div className="version-zone-selector">
          <div className="selector-group">
            <label>Version:</label>
            <select
              value={selectedVersion}
              onChange={e => setSelectedVersion(e.target.value)}
            >
              {versions.list.map(version => (
                <option key={version} value={version}>
                  {versions.metadata[version]?.label || version}
                </option>
              ))}
            </select>
          </div>

          <div className="selector-group">
            <label>Zone:</label>
            <select
              value={selectedZone}
              onChange={e => setSelectedZone(e.target.value)}
            >
              {zones.list.map(zone => (
                <option key={zone} value={zone}>
                  {zones.metadata[zone]?.label || zone}
                </option>
              ))}
            </select>
          </div>
        </div>

        {inheritanceInfo && (
          <div className="inheritance-info">
            <span className="inheritance-label">
              Inherits {inheritanceInfo.percentage}% from {inheritanceInfo.sourceLabel}
            </span>
          </div>
        )}

        <div className="value-editor">
          {editMode ? (
            <>
              <input
                type={parameter.type === 'number' ? 'number' : 'text'}
                value={currentValue}
                onChange={handleValueChange}
                className="value-input"
              />
              <div className="edit-actions">
                <button className="save-button" onClick={handleSave}>Save</button>
                <button className="cancel-button" onClick={() => setEditMode(false)}>Cancel</button>
              </div>
            </>
          ) : (
            <>
              <div className="current-value">
                <span className="value-label">Current Value:</span>
                <span className="value">{currentValue}</span>
              </div>
              <button className="edit-button" onClick={() => setEditMode(true)}>Edit</button>
            </>
          )}
        </div>

        <div className="matrix-table">
          <h3>Matrix Values Preview</h3>
          <table>
            <thead>
              <tr>
                <th>Zone / Version</th>
                {versions.list.map(version => (
                  <th key={version} className={version === selectedVersion ? 'selected' : ''}>
                    {versions.metadata[version]?.label || version}
                  </th>
                ))}
              </tr>
            </thead>
            <tbody>
              {zones.list.map(zone => (
                <tr key={zone}>
                  <td className={zone === selectedZone ? 'selected' : ''}>
                    {zones.metadata[zone]?.label || zone}
                  </td>
                  {versions.list.map(version => (
                    <td
                      key={version}
                      className={version === selectedVersion && zone === selectedZone ? 'selected' : ''}
                      onClick={() => {
                        setSelectedVersion(version);
                        setSelectedZone(zone);
                      }}
                    >
                      {parameter.matrix[version]?.[zone]}
                    </td>
                  ))}
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </div>
    </div>
  );
};

export default MatrixEditDialog;
```

### Step 7: Create Enhanced Scaling Item with Efficacy Support

```javascript
// src/components/ScalingSystem/EnhancedScalingItem.js
import React, { useState } from 'react';
import { useAtom } from 'jotai';
import {
  extendedEfficacyPeriodsAtom,
  updateScalingItemEfficacyAtom
} from '../../atoms/efficacyMatrix';
import { versionsAtom, zonesAtom } from '../../atoms/matrixFormValues';
import { addHistoryEntryAtom } from '../../atoms/matrixHistory';

const EnhancedScalingItem = ({ item, onUpdate, showEfficacyTooltip = true }) => {
  const [efficacyPeriods] = useAtom(extendedEfficacyPeriodsAtom);
  const [, updateEfficacy] = useAtom(updateScalingItemEfficacyAtom);
  const [versions] = useAtom(versionsAtom);
  const [zones] = useAtom(zonesAtom);
  const [, addHistoryEntry] = useAtom(addHistoryEntryAtom);

  const [showEfficacyDialog, setShowEfficacyDialog] = useState(false);
  const [showScaledValueTooltip, setShowScaledValueTooltip] = useState(false);

  // Get efficacy period for this item
  const itemEfficacy = efficacyPeriods[`item_${item.id}`];
  const groupEfficacy = item.groupId ? efficacyPeriods[`group_${item.groupId}`] : null;

  // Determine effective efficacy period
  const effectiveEfficacy = itemEfficacy ||
    (groupEfficacy?.overridesItems ? groupEfficacy : null);

  // Handle scaling factor change
  const handleScalingFactorChange = (e) => {
    const newFactor = parseFloat(e.target.value);
    if (!isNaN(newFactor)) {
      onUpdate({
        ...item,
        scalingFactor: newFactor,
        scaledValue: calculateScaledValue(item.baseValue, newFactor, item.operation)
      });

      addHistoryEntry({
        action: 'update_scaling_factor',
        description: `Updated scaling factor for ${item.label}`
      });
    }
  };

  // Handle operation change
  const handleOperationChange = (e) => {
    const newOperation = e.target.value;
    onUpdate({
      ...item,
      operation: newOperation,
      scaledValue: calculateScaledValue(item.baseValue, item.scalingFactor, newOperation)
    });

    addHistoryEntry({
      action: 'update_scaling_operation',
      description: `Updated scaling operation for ${item.label}`
    });
  };

  // Calculate scaled value based on operation
  const calculateScaledValue = (baseValue, factor, operation) => {
    switch (operation) {
      case 'multiply':
        return baseValue * factor;
      case 'add':
        return baseValue + factor;
      case 'subtract':
        return baseValue - factor;
      case 'divide':
        return factor !== 0 ? baseValue / factor : baseValue;
      default:
        return baseValue;
    }
  };

  // Handle efficacy period update
  const handleEfficacyUpdate = (start, end) => {
    updateEfficacy({
      itemId: item.id,
      start,
      end,
      syncToFormValue: true
    });

    addHistoryEntry({
      action: 'update_scaling_item_efficacy',
      description: `Updated efficacy period for ${item.label}`
    });

    setShowEfficacyDialog(false);
  };

  return (
    <div className={`scaling-item ${item.isActive ? 'active' : 'inactive'}`}>
      <div className="scaling-item-header">
        <span className="item-label">{item.label}</span>
        <div className="item-badges">
          {effectiveEfficacy?.isCustomized && (
            <span
              className="efficacy-badge"
              onClick={() => showEfficacyTooltip && setShowEfficacyDialog(true)}
              title={`Active from year ${effectiveEfficacy.start} to ${effectiveEfficacy.end}`}
            >
              Custom Efficacy
            </span>
          )}

          {item.scaledValue !== item.baseValue && (
            <span
              className="scaled-badge"
              onClick={() => setShowScaledValueTooltip(!showScaledValueTooltip)}
              title="Click to see scaled value details"
            >
              Scaled
            </span>
          )}
        </div>
      </div>

      <div className="scaling-item-controls">
        <div className="scaling-factor-group">
          <input
            type="number"
            value={item.scalingFactor}
            onChange={handleScalingFactorChange}
            className="scaling-factor-input"
            step="0.1"
          />

          <select
            value={item.operation}
            onChange={handleOperationChange}
            className="operation-select"
          >
            <option value="multiply"></option>
            <option value="add">+</option>
            <option value="subtract"></option>
            <option value="divide"></option>
          </select>
        </div>

        <div className="scaled-value-group">
          <div className="base-value">Base: {item.baseValue}</div>
          <div className="scaled-value">
            Scaled: {item.scaledValue}
            {item.isActive ? ' (active)' : ' (inactive)'}
          </div>
        </div>
      </div>

      {showScaledValueTooltip && (
        <div className="scaled-value-tooltip">
          <div className="tooltip-header">
            <h4>Scaled Value Details</h4>
            <button onClick={() => setShowScaledValueTooltip(false)}></button>
          </div>

          <div className="tooltip-content">
            <div className="detail-row">
              <span className="detail-label">Base Value:</span>
              <span className="detail-value">{item.baseValue}</span>
            </div>

            <div className="detail-row">
              <span className="detail-label">Scaling:</span>
              <span className="detail-value">
                {item.operation === 'multiply' ? '' :
                 item.operation === 'add' ? '+' :
                 item.operation === 'subtract' ? '' : ''} {item.scalingFactor}
              </span>
            </div>

            <div className="detail-row">
              <span className="detail-label">Scaled Value:</span>
              <span className="detail-value">{item.scaledValue}</span>
            </div>

            <div className="detail-row">
              <span className="detail-label">Active:</span>
              <span className="detail-value">{item.isActive ? 'Yes' : 'No'}</span>
            </div>

            <div className="detail-row">
              <span className="detail-label">Effective Value:</span>
              <span className="detail-value">
                {item.isActive ? item.scaledValue : item.baseValue}
              </span>
            </div>

            <div className="detail-row">
              <span className="detail-label">Version:</span>
              <span className="detail-value">
                {versions.metadata[versions.active]?.label || versions.active}
              </span>
            </div>

            <div className="detail-row">
              <span className="detail-label">Zone:</span>
              <span className="detail-value">
                {zones.metadata[zones.active]?.label || zones.active}
              </span>
            </div>
          </div>
        </div>
      )}

      {showEfficacyDialog && (
        <div className="efficacy-dialog">
          <div className="dialog-header">
            <h3>Set Efficacy Period for {item.label}</h3>
            <button onClick={() => setShowEfficacyDialog(false)}></button>
          </div>

          <div className="dialog-content">
            <div className="input-group">
              <label>Start Year:</label>
              <input
                type="number"
                min="0"
                value={effectiveEfficacy?.start || 0}
                onChange={(e) => {
                  const start = parseInt(e.target.value) || 0;
                  const end = effectiveEfficacy?.end || 20;
                  handleEfficacyUpdate(start, end);
                }}
              />
            </div>

            <div className="input-group">
              <label>End Year:</label>
              <input
                type="number"
                min={effectiveEfficacy?.start || 0}
                value={effectiveEfficacy?.end || 20}
                onChange={(e) => {
                  const start = effectiveEfficacy?.start || 0;
                  const end = parseInt(e.target.value) || 20;
                  handleEfficacyUpdate(start, end);
                }}
              />
            </div>

            <button
              className="reset-button"
              onClick={() => handleEfficacyUpdate(0, 20)}
            >
              Reset to Full Lifetime
            </button>
          </div>
        </div>
      )}
    </div>
  );
};

export default EnhancedScalingItem;
```

### Step 8: Create Version and Zone Management UI

```javascript
// src/components/MatrixControls.js
import React, { useState } from 'react';
import { useAtom } from 'jotai';
import { versionsAtom, zonesAtom } from '../atoms/matrixFormValues';
import { addHistoryEntryAtom } from '../atoms/matrixHistory';
import { synchronizeWithCalSen } from '../services/calsenSyncService';

const MatrixControls = () => {
  const [versions, setVersions] = useAtom(versionsAtom);
  const [zones, setZones] = useAtom(zonesAtom);
  const [, addHistoryEntry] = useAtom(addHistoryEntryAtom);

  const [showNewVersionDialog, setShowNewVersionDialog] = useState(false);
  const [showNewZoneDialog, setShowNewZoneDialog] = useState(false);
  const [newVersionData, setNewVersionData] = useState({
    label: '',
    description: '',
    baseVersion: null
  });
  const [newZoneData, setNewZoneData] = useState({
    label: '',
    description: ''
  });
  const [syncStatus, setSyncStatus] = useState(null);

  // Set active version
  const setActiveVersion = (versionId) => {
    setVersions({
      ...versions,
      active: versionId
    });

    addHistoryEntry({
      action: 'set_active_version',
      description: `Set active version to ${versions.metadata[versionId]?.label || versionId}`
    });

    // Sync with CalSen
    syncWithCalSen();
  };

  // Set active zone
  const setActiveZone = (zoneId) => {
    setZones({
      ...zones,
      active: zoneId
    });

    addHistoryEntry({
      action: 'set_active_zone',
      description: `Set active zone to ${zones.metadata[zoneId]?.label || zoneId}`
    });

    // Sync with CalSen
    syncWithCalSen();
  };

  // Create new version
  const createNewVersion = () => {
    if (!newVersionData.label) {
      return;
    }

    // Generate version ID
    const versionId = `v${versions.list.length + 1}`;

    // Update versions atom
    setVersions({
      ...versions,
      list: [...versions.list, versionId],
      metadata: {
        ...versions.metadata,
        [versionId]: {
          label: newVersionData.label,
          description: newVersionData.description || `Version created on ${new Date().toLocaleString()}`,
          created: Date.now(),
          modified: Date.now(),
          baseVersion: newVersionData.baseVersion
        }
      }
    });

    addHistoryEntry({
      action: 'create_version',
      description: `Created new version: ${newVersionData.label}`
    });

    // Reset dialog state
    setNewVersionData({
      label: '',
      description: '',
      baseVersion: null
    });
    setShowNewVersionDialog(false);

    // Sync with CalSen
    syncWithCalSen();
  };

  // Create new zone
  const createNewZone = () => {
    if (!newZoneData.label) {
      return;
    }

    // Generate zone ID
    const zoneId = `z${zones.list.length + 1}`;

    // Update zones atom
    setZones({
      ...zones,
      list: [...zones.list, zoneId],
      metadata: {
        ...zones.metadata,
        [zoneId]: {
          label: newZoneData.label,
          description: newZoneData.description || `Zone created on ${new Date().toLocaleString()}`,
          created: Date.now()
        }
      }
    });

    addHistoryEntry({
      action: 'create_zone',
      description: `Created new zone: ${newZoneData.label}`
    });

    // Reset dialog state
    setNewZoneData({
      label: '',
      description: ''
    });
    setShowNewZoneDialog(false);

    // Sync with CalSen
    syncWithCalSen();
  };

  // Sync with CalSen
  const syncWithCalSen = async () => {
    setSyncStatus('syncing');

    try {
      const result = await synchronizeWithCalSen({
        versions,
        zones
      });

      if (result.success) {
        setSyncStatus('success');

        // Clear status after 3 seconds
        setTimeout(() => {
          setSyncStatus(null);
        }, 3000);
      } else {
        setSyncStatus('error');
        console.error('Sync error:', result.message);

        // Clear status after 5 seconds
        setTimeout(() => {
          setSyncStatus(null);
        }, 5000);
      }
    } catch (error) {
      setSyncStatus('error');
      console.error('Sync error:', error);

      // Clear status after 5 seconds
      setTimeout(() => {
        setSyncStatus(null);
      }, 5000);
    }
  };

  return (
    <div className="matrix-controls">
      <div className="matrix-selector">
        <div className="version-selector">
          <h3>Version</h3>
          <div className="selector-items">
            {versions.list.map(versionId => (
              <div
                key={versionId}
                className={`selector-item ${versionId === versions.active ? 'active' : ''}`}
                onClick={() => setActiveVersion(versionId)}
              >
                {versions.metadata[versionId]?.label || versionId}
              </div>
            ))}
            <div
              className="selector-item add-item"
              onClick={() => setShowNewVersionDialog(true)}
            >
              + Add Version
            </div>
          </div>
        </div>

        <div className="zone-selector">
          <h3>Zone</h3>
          <div className="selector-items">
            {zones.list.map(zoneId => (
              <div
                key={zoneId}
                className={`selector-item ${zoneId === zones.active ? 'active' : ''}`}
                onClick={() => setActiveZone(zoneId)}
              >
                {zones.metadata[zoneId]?.label || zoneId}
              </div>
            ))}
            <div
              className="selector-item add-item"
              onClick={() => setShowNewZoneDialog(true)}
            >
              + Add Zone
            </div>
          </div>
        </div>
      </div>

      <div className="sync-status">
        {syncStatus === 'syncing' && <span className="syncing">Synchronizing...</span>}
        {syncStatus === 'success' && <span className="success">Synchronized successfully</span>}
        {syncStatus === 'error' && <span className="error">Synchronization failed</span>}
      </div>

      {/* New Version Dialog */}
      {showNewVersionDialog && (
        <div className="dialog-overlay">
          <div className="dialog">
            <div className="dialog-header">
              <h3>Create New Version</h3>
              <button onClick={() => setShowNewVersionDialog(false)}></button>
            </div>

            <div className="dialog-content">
              <div className="input-group">
                <label>Label:</label>
                <input
                  type="text"
                  value={newVersionData.label}
                  onChange={e => setNewVersionData({...newVersionData, label: e.target.value})}
                  placeholder="e.g., High Growth Scenario"
                />
              </div>

              <div className="input-group">
                <label>Description:</label>
                <textarea
                  value={newVersionData.description}
                  onChange={e => setNewVersionData({...newVersionData, description: e.target.value})}
                  placeholder="Description of this version"
                />
              </div>

              <div className="input-group">
                <label>Base Version:</label>
                <select
                  value={newVersionData.baseVersion || ''}
                  onChange={e => setNewVersionData({
                    ...newVersionData,
                    baseVersion: e.target.value || null
                  })}
                >
                  <option value="">None (Start from scratch)</option>
                  {versions.list.map(versionId => (
                    <option key={versionId} value={versionId}>
                      {versions.metadata[versionId]?.label || versionId}
                    </option>
                  ))}
                </select>
                {newVersionData.baseVersion && (
                  <p className="help-text">
                    The new version will inherit 70% of values from the base version.
                  </p>
                )}
              </div>
            </div>

            <div className="dialog-actions">
              <button onClick={() => setShowNewVersionDialog(false)}>Cancel</button>
              <button
                onClick={createNewVersion}
                disabled={!newVersionData.label}
                className="primary"
              >
                Create Version
              </button>
            </div>
          </div>
        </div>
      )}

      {/* New Zone Dialog */}
      {showNewZoneDialog && (
        <div className="dialog-overlay">
          <div className="dialog">
            <div className="dialog-header">
              <h3>Create New Zone</h3>
              <button onClick={() => setShowNewZoneDialog(false)}></button>
            </div>

            <div className="dialog-content">
              <div className="input-group">
                <label>Label:</label>
                <input
                  type="text"
                  value={newZoneData.label}
                  onChange={e => setNewZoneData({...newZoneData, label: e.target.value})}
                  placeholder="e.g., Export Market"
                />
              </div>

              <div className="input-group">
                <label>Description:</label>
                <textarea
                  value={newZoneData.description}
                  onChange={e => setNewZoneData({...newZoneData, description: e.target.value})}
                  placeholder="Description of this zone"
                />
              </div>
            </div>

            <div className="dialog-actions">
              <button onClick={() => setShowNewZoneDialog(false)}>Cancel</button>
              <button
                onClick={createNewZone}
                disabled={!newZoneData.label}
                className="primary"
              >
                Create Zone
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default MatrixControls;
```

## Phase 4: Integration with CFA Calculations

### Step 9: Create Calculation Service

```javascript
// src/services/calculationService.js
import axios from 'axios';
import { calsenSyncService } from './calsenSyncService';

// Calculation service base URL
const CALCULATION_BASE_URL = 'http://localhost:2500';

// Create axios instance for Calculation API
const calculationApi = axios.create({
  baseURL: CALCULATION_BASE_URL,
  timeout: 60000, // 1 minute timeout
  headers: {
    'Content-Type': 'application/json'
  }
});

/**
 * Register payload with calculation service
 * @param {Object} payload Complete application state payload
 * @returns {Promise<Object>} Registration result
 */
export const registerPayload = async (payload) => {
  try {
    const response = await calculationApi.post('/register_payload', payload);

    return {
      success: true,
      message: 'Payload registered successfully',
      runId: response.data.runId
    };
  } catch (error) {
    console.error('Error registering payload:', error);
    return {
      success: false,
      message: `Error registering payload: ${error.message}`,
      error
    };
  }
};

/**
 * Run baseline calculation
 * @param {Object} config Calculation configuration
 * @returns {Promise<Object>} Calculation result
 */
export const runBaselineCalculation = async (config) => {
  try {
    // First synchronize with CalSen to make sure all state is up to date
    await calsenSyncService.synchronizeWithCalSen({
      formValues: config.formValues,
      scalingGroups: config.scalingGroups,
      runOptions: config.runOptions,
      visualizationState: config.visualizationState
    });

    // Generate config matrix CSV
    await calsenSyncService.generateConfigMatrix(config.version);

    // Export paths for calculation
    await calsenSyncService.exportPathsForCalculation(config.version);

    // Run baseline calculation
    const response = await calculationApi.post('/baseline_calculation', {
      runId: config.runId,
      selectedVersions: [config.version],
      selectedV: config.selectedV,
      selectedF: config.selectedF,
      selectedR: config.selectedR,
      selectedRF: config.selectedRF,
      selectedCalculationOption: config.calculationOption,
      targetRow: config.targetRow
    });

    return {
      success: true,
      message: 'Baseline calculation completed successfully',
      result: response.data
    };
  } catch (error) {
    console.error('Error running baseline calculation:', error);
    return {
      success: false,
      message: `Error running baseline calculation: ${error.message}`,
      error
    };
  }
};

/**
 * Configure sensitivity analysis
 * @param {Object} config Sensitivity configuration
 * @returns {Promise<Object>} Configuration result
 */
export const configureSensitivity = async (config) => {
  try {
    const response = await calculationApi.post('/sensitivity/configure', {
      runId: config.runId,
      selectedVersions: [config.version],
      selectedV: config.selectedV,
      selectedF: config.selectedF,
      selectedR: config.selectedR,
      selectedRF: config.selectedRF,
      selectedCalculationOption: config.calculationOption,
      targetRow: config.targetRow,
      SenParameters: config.SenParameters
    });

    return {
      success: true,
      message: 'Sensitivity configuration completed successfully',
      result: response.data
    };
  } catch (error) {
    console.error('Error configuring sensitivity:', error);
    return {
      success: false,
      message: `Error configuring sensitivity: ${error.message}`,
      error
    };
  }
};

/**
 * Run sensitivity calculations
 * @param {Object} config Run configuration
 * @returns {Promise<Object>} Run result
 */
export const runSensitivityCalculations = async (config) => {
  try {
    const response = await calculationApi.post('/runs', {
      runId: config.runId,
      selectedVersions: [config.version],
      selectedV: config.selectedV,
      selectedF: config.selectedF,
      selectedR: config.selectedR,
      selectedRF: config.selectedRF,
      selectedCalculationOption: config.calculationOption,
      targetRow: config.targetRow,
      SenParameters: config.SenParameters
    });

    return {
      success: true,
      message: 'Sensitivity calculations completed successfully',
      result: response.data
    };
  } catch (error) {
    console.error('Error running sensitivity calculations:', error);
    return {
      success: false,
      message: `Error running sensitivity calculations: ${error.message}`,
      error
    };
  }
};

/**
 * Run all sensitivity steps in sequence
 * @param {Object} config Complete configuration
 * @returns {Promise<Object>} Complete result
 */
export const runFullSensitivityAnalysis = async (config) => {
  try {
    // First register payload
    const registerResult = await registerPayload({
      selectedVersions: [config.version],
      selectedV: config.selectedV,
      selectedF: config.selectedF,
      selectedR: config.selectedR,
      selectedRF: config.selectedRF,
      selectedCalculationOption: config.calculationOption,
      targetRow: config.targetRow,
      SenParameters: config.SenParameters
    });

    if (!registerResult.success) {
      return registerResult;
    }

    // Run baseline calculation
    const baselineResult = await runBaselineCalculation({
      ...config,
      runId: registerResult.runId
    });

    if (!baselineResult.success) {
      return baselineResult;
    }

    // Configure sensitivity
    const configResult = await configureSensitivity({
      ...config,
      runId: registerResult.runId
    });

    if (!configResult.success) {
      return configResult;
    }

    // Run sensitivity calculations
    const runsResult = await runSensitivityCalculations({
      ...config,
      runId: registerResult.runId
    });

    return {
      success: runsResult.success,
      message: 'Full sensitivity analysis completed successfully',
      phases: {
        register: registerResult,
        baseline: baselineResult,
        configure: configResult,
        runs: runsResult
      },
      runId: registerResult.runId
    };
  } catch (error) {
    console.error('Error running full sensitivity analysis:', error);
    return {
      success: false,
      message: `Error running full sensitivity analysis: ${error.message}`,
      error
    };
  }
};

export default {
  registerPayload,
  runBaselineCalculation,
  configureSensitivity,
  runSensitivityCalculations,
  runFullSensitivityAnalysis
};
```

### Step 10: Create Main App with Complete Integration

```javascript
// src/App.js
import React, { useEffect } from 'react';
import { Provider } from 'jotai';
import { useAtom } from 'jotai';
import {
  formValuesMatrixAtom,
  initializeFormValueMatrixAtom
} from './atoms/matrixFormValues';
import {
  initializeEfficacyPeriodsAtom
} from './atoms/efficacyMatrix';
import {
  addHistoryEntryAtom
} from './atoms/matrixHistory';
import { checkCalSenHealth } from './services/calsenSyncService';

import MatrixControls from './components/MatrixControls';
import FormConfig from './components/FormConfig';
import ScalingSystem from './components/ScalingSystem/ScalingSystem';
import RunOptions from './components/RunOptions';
import HistoryControls from './components/HistoryControls';
import './styles/App.css';

// Main App component
const AppContent = () => {
  const [formMatrix] = useAtom(formValuesMatrixAtom);
  const [, initializeFormValueMatrix] = useAtom(initializeFormValueMatrixAtom);
  const [, initializeEfficacyPeriods] = useAtom(initializeEfficacyPeriodsAtom);
  const [, addHistoryEntry] = useAtom(addHistoryEntryAtom);
  const [healthStatus, setHealthStatus] = React.useState({
    checked: false,
    healthy: false,
    message: 'Checking services...'
  });

  // Initialize form matrix on first load
  useEffect(() => {
    const initialize = async () => {
      // Check CalSen health first
      const health = await checkCalSenHealth();
      setHealthStatus({
        checked: true,
        healthy: health.healthy,
        message: health.healthy ?
          'Services are healthy' :
          'CalSen service is not available - some features may not work'
      });

      // Initialize form matrix
      initializeFormValueMatrix();

      // Initialize efficacy periods
      initializeEfficacyPeriods();

      // Add initial history entry
      addHistoryEntry({
        action: 'initialize',
        description: 'Initialized application state'
      });
    };

    initialize();
  }, []);

  // Count parameters in form matrix
  const parameterCount = Object.keys(formMatrix).length;

  return (
    <div className="app">
      <header className="app-header">
        <h1>ModEcon Matrix System</h1>
        <div className="header-controls">
          <div className={`health-status ${healthStatus.healthy ? 'healthy' : 'unhealthy'}`}>
            {healthStatus.message}
          </div>
          <HistoryControls />
        </div>
      </header>

      <div className="app-container">
        <aside className="app-sidebar">
          <MatrixControls />
          <RunOptions />
        </aside>

        <main className="app-content">
          <div className="content-header">
            <h2>Financial Case Builder</h2>
            <div className="status-info">
              Parameters: {parameterCount}
            </div>
          </div>

          <div className="content-body">
            <div className="panel form-panel">
              <FormConfig />
            </div>

            <div className="panel scaling-panel">
              <ScalingSystem />
            </div>
          </div>
        </main>
      </div>
    </div>
  );
};

// Wrap with Jotai provider
const App = () => (
  <Provider>
    <AppContent />
  </Provider>
);

export default App;
```


# Phase 5: Enhanced Scaling Results Visualization and Integration

## Step 11: Create Enhanced Summary Items Panel

```javascript
// src/components/ScalingSystem/EnhancedSummaryPanel.js
import React, { useState, useEffect } from 'react';
import { useAtom } from 'jotai';
import { motion, AnimatePresence } from 'framer-motion';
import {
  formValuesMatrixAtom,
  versionsAtom,
  zonesAtom
} from '../../atoms/matrixFormValues';
import {
  efficacyAwareScalingGroupsAtom,
  simulationTimeAtom
} from '../../atoms/efficacyMatrix';

const EnhancedSummaryPanel = () => {
  const [formMatrix] = useAtom(formValuesMatrixAtom);
  const [versions] = useAtom(versionsAtom);
  const [zones] = useAtom(zonesAtom);
  const [efficacyGroups] = useAtom(efficacyAwareScalingGroupsAtom);
  const [simTime, setSimTime] = useAtom(simulationTimeAtom);

  const [searchTerm, setSearchTerm] = useState('');
  const [sortBy, setSortBy] = useState('impact');
  const [sortDirection, setSortDirection] = useState('desc');
  const [filterActive, setFilterActive] = useState(false);
  const [selectedItem, setSelectedItem] = useState(null);
  const [summaryView, setSummaryView] = useState('compact'); // 'compact', 'detailed', 'chart'

  // Generate summary items from efficacy groups
  const generateSummaryItems = () => {
    // Initialize flatted items array
    const items = [];

    efficacyGroups.forEach(group => {
      group.items.forEach(item => {
        // Calculate percentage change
        const percentChange = item.baseValue !== 0
          ? ((item.scaledValue - item.baseValue) / Math.abs(item.baseValue)) * 100
          : 0;

        // Calculate absolute impact
        const absImpact = Math.abs(item.scaledValue - item.baseValue);

        // Add to items array
        items.push({
          id: item.id,
          label: item.label || item.id,
          baseValue: item.baseValue,
          scaledValue: item.scaledValue,
          effectiveValue: item.effectiveValue,
          percentChange,
          absImpact,
          isActive: item.isActive,
          groupId: group.id,
          groupName: group.name
        });
      });
    });

    return items;
  };

  // Filter and sort summary items
  const processedItems = React.useMemo(() => {
    const summaryItems = generateSummaryItems();

    // Apply search filter
    let filtered = summaryItems;
    if (searchTerm) {
      const term = searchTerm.toLowerCase();
      filtered = summaryItems.filter(item =>
        item.label.toLowerCase().includes(term) ||
        item.id.toLowerCase().includes(term) ||
        item.groupName.toLowerCase().includes(term)
      );
    }

    // Apply active filter
    if (filterActive) {
      filtered = filtered.filter(item => item.isActive);
    }

    // Apply sorting
    const sorted = [...filtered].sort((a, b) => {
      let comparison = 0;

      switch (sortBy) {
        case 'impact':
          comparison = a.absImpact - b.absImpact;
          break;
        case 'percent':
          comparison = a.percentChange - b.percentChange;
          break;
        case 'name':
          comparison = a.label.localeCompare(b.label);
          break;
        case 'group':
          comparison = a.groupName.localeCompare(b.groupName);
          break;
        default:
          comparison = a.absImpact - b.absImpact;
      }

      return sortDirection === 'asc' ? comparison : -comparison;
    });

    return sorted;
  }, [efficacyGroups, searchTerm, sortBy, sortDirection, filterActive, simTime]);

  // Toggle sort direction when clicking the same column
  const handleSortClick = (column) => {
    if (sortBy === column) {
      setSortDirection(sortDirection === 'asc' ? 'desc' : 'asc');
    } else {
      setSortBy(column);
      setSortDirection('desc');
    }
  };

  // Format number for display
  const formatNumber = (num) => {
    if (Math.abs(num) >= 1000000) {
      return (num / 1000000).toFixed(2) + 'M';
    } else if (Math.abs(num) >= 1000) {
      return (num / 1000).toFixed(2) + 'K';
    } else {
      return num.toFixed(2);
    }
  };

  // Calculate statistics
  const stats = React.useMemo(() => {
    if (processedItems.length === 0) return null;

    const activeItems = processedItems.filter(item => item.isActive);
    const totalChange = activeItems.reduce((sum, item) => sum + (item.scaledValue - item.baseValue), 0);
    const averagePercentChange = activeItems.length > 0
      ? activeItems.reduce((sum, item) => sum + item.percentChange, 0) / activeItems.length
      : 0;
    const maxImpact = [...activeItems].sort((a, b) => b.absImpact - a.absImpact)[0] || null;

    return {
      totalChange,
      averagePercentChange,
      maxImpact,
      activeCount: activeItems.length,
      totalCount: processedItems.length
    };
  }, [processedItems]);

  return (
    <div className="enhanced-summary-panel">
      <div className="summary-header">
        <h3>Scaling Results Summary</h3>

        <div className="summary-controls">
          <div className="search-control">
            <input
              type="text"
              placeholder="Search items..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              className="search-input"
            />
          </div>

          <div className="filter-control">
            <label className="filter-label">
              <input
                type="checkbox"
                checked={filterActive}
                onChange={() => setFilterActive(!filterActive)}
                className="filter-checkbox"
              />
              Active only
            </label>
          </div>

          <div className="view-control">
            <button
              className={`view-button ${summaryView === 'compact' ? 'active' : ''}`}
              onClick={() => setSummaryView('compact')}
              title="Compact View"
            >
              <span className="icon"></span>
            </button>

            <button
              className={`view-button ${summaryView === 'detailed' ? 'active' : ''}`}
              onClick={() => setSummaryView('detailed')}
              title="Detailed View"
            >
              <span className="icon">+</span>
            </button>

            <button
              className={`view-button ${summaryView === 'chart' ? 'active' : ''}`}
              onClick={() => setSummaryView('chart')}
              title="Chart View"
            >
              <span className="icon"></span>
            </button>
          </div>

          <div className="simulation-control">
            <label className="sim-label">Simulation Year:</label>
            <input
              type="range"
              min="0"
              max="20"
              value={simTime}
              onChange={(e) => setSimTime(parseInt(e.target.value))}
              className="sim-slider"
            />
            <span className="sim-value">{simTime}</span>
          </div>
        </div>
      </div>

      {stats && (
        <div className="summary-stats">
          <div className="stat-item">
            <span className="stat-label">Active Items:</span>
            <span className="stat-value">{stats.activeCount} / {stats.totalCount}</span>
          </div>

          <div className="stat-item">
            <span className="stat-label">Total Change:</span>
            <span className={`stat-value ${stats.totalChange > 0 ? 'positive' : stats.totalChange < 0 ? 'negative' : ''}`}>
              {formatNumber(stats.totalChange)}
            </span>
          </div>

          <div className="stat-item">
            <span className="stat-label">Avg. % Change:</span>
            <span className={`stat-value ${stats.averagePercentChange > 0 ? 'positive' : stats.averagePercentChange < 0 ? 'negative' : ''}`}>
              {stats.averagePercentChange.toFixed(2)}%
            </span>
          </div>

          {stats.maxImpact && (
            <div className="stat-item">
              <span className="stat-label">Max Impact:</span>
              <span className="stat-value">{stats.maxImpact.label} ({formatNumber(stats.maxImpact.absImpact)})</span>
            </div>
          )}
        </div>
      )}

      {summaryView === 'compact' && (
        <table className="summary-table compact">
          <thead>
            <tr>
              <th className="status-col">Status</th>
              <th
                className={`name-col ${sortBy === 'name' ? 'sorted' : ''}`}
                onClick={() => handleSortClick('name')}
              >
                Name {sortBy === 'name' && (sortDirection === 'asc' ? '' : '')}
              </th>
              <th
                className={`group-col ${sortBy === 'group' ? 'sorted' : ''}`}
                onClick={() => handleSortClick('group')}
              >
                Group {sortBy === 'group' && (sortDirection === 'asc' ? '' : '')}
              </th>
              <th
                className={`impact-col ${sortBy === 'impact' ? 'sorted' : ''}`}
                onClick={() => handleSortClick('impact')}
              >
                Impact {sortBy === 'impact' && (sortDirection === 'asc' ? '' : '')}
              </th>
              <th
                className={`percent-col ${sortBy === 'percent' ? 'sorted' : ''}`}
                onClick={() => handleSortClick('percent')}
              >
                % Change {sortBy === 'percent' && (sortDirection === 'asc' ? '' : '')}
              </th>
            </tr>
          </thead>
          <tbody>
            {processedItems.map(item => (
              <motion.tr
                key={item.id}
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                exit={{ opacity: 0 }}
                className={`summary-row ${item.isActive ? 'active' : 'inactive'}`}
                onClick={() => setSelectedItem(selectedItem?.id === item.id ? null : item)}
              >
                <td className="status-col">
                  <span className={`status-indicator ${item.isActive ? 'active' : 'inactive'}`}></span>
                </td>
                <td className="name-col">{item.label}</td>
                <td className="group-col">{item.groupName}</td>
                <td className={`impact-col ${item.scaledValue > item.baseValue ? 'positive' : item.scaledValue < item.baseValue ? 'negative' : ''}`}>
                  {formatNumber(item.scaledValue - item.baseValue)}
                </td>
                <td className={`percent-col ${item.percentChange > 0 ? 'positive' : item.percentChange < 0 ? 'negative' : ''}`}>
                  {item.percentChange.toFixed(2)}%
                </td>
              </motion.tr>
            ))}

            {processedItems.length === 0 && (
              <tr>
                <td colSpan="5" className="no-items">No matching items found</td>
              </tr>
            )}
          </tbody>
        </table>
      )}

      {summaryView === 'detailed' && (
        <div className="detailed-items">
          {processedItems.map(item => (
            <motion.div
              key={item.id}
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              exit={{ opacity: 0 }}
              className={`detailed-item ${item.isActive ? 'active' : 'inactive'}`}
              onClick={() => setSelectedItem(selectedItem?.id === item.id ? null : item)}
            >
              <div className="item-header">
                <div className="item-title">
                  <span className={`status-indicator ${item.isActive ? 'active' : 'inactive'}`}></span>
                  <h4>{item.label}</h4>
                </div>
                <div className="item-group">{item.groupName}</div>
              </div>

              <div className="item-values">
                <div className="value-row">
                  <span className="value-label">Base Value:</span>
                  <span className="value">{formatNumber(item.baseValue)}</span>
                </div>

                <div className="value-row">
                  <span className="value-label">Scaled Value:</span>
                  <span className="value">{formatNumber(item.scaledValue)}</span>
                </div>

                <div className="value-row">
                  <span className="value-label">Effective Value:</span>
                  <span className="value highlight">{formatNumber(item.effectiveValue)}</span>
                </div>

                <div className="value-row">
                  <span className="value-label">Change:</span>
                  <span className={`value ${item.scaledValue > item.baseValue ? 'positive' : item.scaledValue < item.baseValue ? 'negative' : ''}`}>
                    {formatNumber(item.scaledValue - item.baseValue)}
                  </span>
                </div>

                <div className="value-row">
                  <span className="value-label">% Change:</span>
                  <span className={`value ${item.percentChange > 0 ? 'positive' : item.percentChange < 0 ? 'negative' : ''}`}>
                    {item.percentChange.toFixed(2)}%
                  </span>
                </div>
              </div>
            </motion.div>
          ))}

          {processedItems.length === 0 && (
            <div className="no-items">No matching items found</div>
          )}
        </div>
      )}

      {summaryView === 'chart' && (
        <div className="chart-view">
          <div className="chart-container">
            {/* Chart implementation would go here - simplified for this example */}
            <div className="chart-placeholder">
              <h4>Impact Chart</h4>
              {processedItems.slice(0, 10).map((item, index) => {
                const maxImpact = Math.max(...processedItems.map(i => Math.abs(i.scaledValue - i.baseValue)));
                const barWidth = `${(Math.abs(item.scaledValue - item.baseValue) / maxImpact) * 100}%`;
                const isPositive = item.scaledValue > item.baseValue;

                return (
                  <div key={item.id} className="chart-bar-container">
                    <div className="bar-label">{item.label}</div>
                    <div className="bar-wrapper">
                      <div
                        className={`chart-bar ${isPositive ? 'positive' : 'negative'}`}
                        style={{
                          width: barWidth,
                          [isPositive ? 'marginLeft' : 'marginRight']: '50%'
                        }}
                      ></div>
                    </div>
                    <div className="bar-value">{formatNumber(item.scaledValue - item.baseValue)}</div>
                  </div>
                );
              })}
            </div>
          </div>
        </div>
      )}

      <AnimatePresence>
        {selectedItem && (
          <motion.div
            className="item-detail-modal"
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: 20 }}
          >
            <div className="modal-header">
              <h3>{selectedItem.label} Details</h3>
              <button onClick={() => setSelectedItem(null)}></button>
            </div>

            <div className="modal-content">
              <div className="detail-section">
                <h4>General Information</h4>
                <div className="detail-row">
                  <span className="detail-label">ID:</span>
                  <span className="detail-value">{selectedItem.id}</span>
                </div>

                <div className="detail-row">
                  <span className="detail-label">Group:</span>
                  <span className="detail-value">{selectedItem.groupName}</span>
                </div>

                <div className="detail-row">
                  <span className="detail-label">Status:</span>
                  <span className={`detail-value status-${selectedItem.isActive ? 'active' : 'inactive'}`}>
                    {selectedItem.isActive ? 'Active' : 'Inactive'}
                  </span>
                </div>
              </div>

              <div className="detail-section">
                <h4>Value Information</h4>
                <div className="detail-row">
                  <span className="detail-label">Base Value:</span>
                  <span className="detail-value">{selectedItem.baseValue.toFixed(4)}</span>
                </div>

                <div className="detail-row">
                  <span className="detail-label">Scaled Value:</span>
                  <span className="detail-value">{selectedItem.scaledValue.toFixed(4)}</span>
                </div>

                <div className="detail-row">
                  <span className="detail-label">Effective Value:</span>
                  <span className="detail-value highlight">{selectedItem.effectiveValue.toFixed(4)}</span>
                </div>

                <div className="detail-row">
                  <span className="detail-label">Absolute Change:</span>
                  <span className={`detail-value ${selectedItem.scaledValue > selectedItem.baseValue ? 'positive' : selectedItem.scaledValue < selectedItem.baseValue ? 'negative' : ''}`}>
                    {(selectedItem.scaledValue - selectedItem.baseValue).toFixed(4)}
                  </span>
                </div>

                <div className="detail-row">
                  <span className="detail-label">Percent Change:</span>
                  <span className={`detail-value ${selectedItem.percentChange > 0 ? 'positive' : selectedItem.percentChange < 0 ? 'negative' : ''}`}>
                    {selectedItem.percentChange.toFixed(4)}%
                  </span>
                </div>
              </div>

              <div className="detail-section">
                <h4>Matrix Information</h4>
                <div className="detail-row">
                  <span className="detail-label">Active Version:</span>
                  <span className="detail-value">{versions.metadata[versions.active]?.label || versions.active}</span>
                </div>

                <div className="detail-row">
                  <span className="detail-label">Active Zone:</span>
                  <span className="detail-value">{zones.metadata[zones.active]?.label || zones.active}</span>
                </div>

                <div className="detail-row">
                  <span className="detail-label">Simulation Year:</span>
                  <span className="detail-value">{simTime}</span>
                </div>
              </div>
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
};

export default EnhancedSummaryPanel;
```

## Step 12: Implement Rich Value Tooltips

```javascript
// src/components/common/ValueTooltip.js
import React, { useState, useRef, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useAtom } from 'jotai';
import { efficacyAwareScalingGroupsAtom } from '../../atoms/efficacyMatrix';
import { versionsAtom, zonesAtom } from '../../atoms/matrixFormValues';

const ValueTooltip = ({
  children,
  itemId,
  showMatrix = false,
  showDetails = true,
  position = 'top', // 'top', 'bottom', 'left', 'right'
  width = 320,
  maxHeight = 400
}) => {
  const [versions] = useAtom(versionsAtom);
  const [zones] = useAtom(zonesAtom);
  const [efficacyGroups] = useAtom(efficacyAwareScalingGroupsAtom);
  const [isVisible, setIsVisible] = useState(false);
  const [tooltipContent, setTooltipContent] = useState(null);
  const containerRef = useRef(null);
  const tooltipRef = useRef(null);

  // Find the item in the efficacy groups
  useEffect(() => {
    if (!itemId) {
      setTooltipContent(null);
      return;
    }

    let foundItem = null;
    let foundGroup = null;

    efficacyGroups.forEach(group => {
      group.items.forEach(item => {
        if (item.id === itemId) {
          foundItem = item;
          foundGroup = group;
        }
      });
    });

    if (!foundItem) {
      setTooltipContent(null);
      return;
    }

    // Calculate percentage change
    const percentChange = foundItem.baseValue !== 0
      ? ((foundItem.scaledValue - foundItem.baseValue) / Math.abs(foundItem.baseValue)) * 100
      : 0;

    setTooltipContent({
      item: foundItem,
      group: foundGroup,
      percentChange,
    });
  }, [itemId, efficacyGroups]);

  // Format number for display
  const formatNumber = (num) => {
    if (typeof num !== 'number') return 'N/A';

    if (Math.abs(num) >= 1000000) {
      return (num / 1000000).toFixed(2) + 'M';
    } else if (Math.abs(num) >= 1000) {
      return (num / 1000).toFixed(2) + 'K';
    } else {
      return num.toFixed(2);
    }
  };

  // Position the tooltip based on container position
  const getTooltipPosition = () => {
    if (!containerRef.current || !tooltipRef.current) {
      return { top: 0, left: 0 };
    }

    const containerRect = containerRef.current.getBoundingClientRect();
    const tooltipRect = tooltipRef.current.getBoundingClientRect();
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;

    let top = 0;
    let left = 0;

    switch (position) {
      case 'top':
        top = -tooltipRect.height - 10;
        left = (containerRect.width - tooltipRect.width) / 2;
        break;
      case 'bottom':
        top = containerRect.height + 10;
        left = (containerRect.width - tooltipRect.width) / 2;
        break;
      case 'left':
        top = (containerRect.height - tooltipRect.height) / 2;
        left = -tooltipRect.width - 10;
        break;
      case 'right':
        top = (containerRect.height - tooltipRect.height) / 2;
        left = containerRect.width + 10;
        break;
      default:
        top = -tooltipRect.height - 10;
        left = (containerRect.width - tooltipRect.width) / 2;
    }

    // Adjust if tooltip would be off-screen
    const tooltipRight = containerRect.left + left + tooltipRect.width;
    const tooltipBottom = containerRect.top + top + tooltipRect.height;

    if (tooltipRight > windowWidth) {
      left -= tooltipRight - windowWidth + 10;
    }

    if (containerRect.left + left < 0) {
      left = -containerRect.left + 10;
    }

    if (tooltipBottom > windowHeight) {
      top -= tooltipBottom - windowHeight + 10;
    }

    if (containerRect.top + top < 0) {
      top = -containerRect.top + 10;
    }

    return { top, left };
  };

  // Get tooltip size
  const getTooltipSize = () => {
    return {
      width: `${width}px`,
      maxHeight: `${maxHeight}px`,
    };
  };

  return (
    <div
      ref={containerRef}
      className="tooltip-container"
      onMouseEnter={() => setIsVisible(true)}
      onMouseLeave={() => setIsVisible(false)}
    >
      {children}

      <AnimatePresence>
        {isVisible && tooltipContent && (
          <motion.div
            ref={tooltipRef}
            className={`value-tooltip tooltip-${position}`}
            style={{
              ...getTooltipSize(),
              ...getTooltipPosition(),
            }}
            initial={{ opacity: 0, scale: 0.9 }}
            animate={{ opacity: 1, scale: 1 }}
            exit={{ opacity: 0, scale: 0.9 }}
            transition={{ duration: 0.2 }}
          >
            <div className="tooltip-content">
              <div className="tooltip-header">
                <h4>{tooltipContent.item.label || tooltipContent.item.id}</h4>
                <span className={`status-indicator ${tooltipContent.item.isActive ? 'active' : 'inactive'}`}>
                  {tooltipContent.item.isActive ? 'Active' : 'Inactive'}
                </span>
              </div>

              {tooltipContent.group && (
                <div className="tooltip-group">
                  <span className="group-label">Group:</span>
                  <span className="group-name">{tooltipContent.group.name}</span>
                </div>
              )}

              {showDetails && (
                <div className="tooltip-details">
                  <div className="detail-row">
                    <span className="detail-label">Base Value:</span>
                    <span className="detail-value">{formatNumber(tooltipContent.item.baseValue)}</span>
                  </div>

                  <div className="detail-row">
                    <span className="detail-label">Scaled Value:</span>
                    <span className="detail-value">{formatNumber(tooltipContent.item.scaledValue)}</span>
                  </div>

                  <div className="detail-row highlight">
                    <span className="detail-label">Effective Value:</span>
                    <span className="detail-value highlight">{formatNumber(tooltipContent.item.effectiveValue)}</span>
                  </div>

                  <div className="detail-row">
                    <span className="detail-label">Change:</span>
                    <span className={`detail-value ${tooltipContent.item.scaledValue > tooltipContent.item.baseValue ? 'positive' : tooltipContent.item.scaledValue < tooltipContent.item.baseValue ? 'negative' : ''}`}>
                      {formatNumber(tooltipContent.item.scaledValue - tooltipContent.item.baseValue)}
                      {tooltipContent.percentChange !== 0 && (
                        <span className="percent-change">
                          ({tooltipContent.percentChange > 0 ? '+' : ''}{tooltipContent.percentChange.toFixed(2)}%)
                        </span>
                      )}
                    </span>
                  </div>

                  {tooltipContent.item.efficacyPeriod && (
                    <div className="detail-row">
                      <span className="detail-label">Efficacy Period:</span>
                      <span className="detail-value">
                        Years {tooltipContent.item.efficacyPeriod.start} - {tooltipContent.item.efficacyPeriod.end}
                      </span>
                    </div>
                  )}
                </div>
              )}

              {showMatrix && (
                <div className="tooltip-matrix">
                  <h5>Matrix Values</h5>
                  <div className="matrix-info">
                    <div className="matrix-row">
                      <span className="matrix-label">Version:</span>
                      <span className="matrix-value">{versions.metadata[versions.active]?.label || versions.active}</span>
                    </div>

                    <div className="matrix-row">
                      <span className="matrix-label">Zone:</span>
                      <span className="matrix-value">{zones.metadata[zones.active]?.label || zones.active}</span>
                    </div>
                  </div>
                </div>
              )}
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
};

export default ValueTooltip;
```

## Step 13: Create Advanced Scaling Group Component

```javascript
// src/components/ScalingSystem/AdvancedScalingGroup.js
import React, { useState, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useAtom } from 'jotai';
import { addHistoryEntryAtom } from '../../atoms/matrixHistory';
import EnhancedScalingItem from './EnhancedScalingItem';
import ValueTooltip from '../common/ValueTooltip';

const AdvancedScalingGroup = ({ group, onUpdate, onRemove, isProtected }) => {
  const [, addHistoryEntry] = useAtom(addHistoryEntryAtom);
  const [isExpanded, setIsExpanded] = useState(true);
  const [isEditing, setIsEditing] = useState(false);
  const [showSummary, setShowSummary] = useState(false);
  const [groupName, setGroupName] = useState(group.name);
  const [draggedItem, setDraggedItem] = useState(null);
  const [dropTarget, setDropTarget] = useState(null);
  const groupRef = useRef(null);

  // Calculate group statistics
  const stats = React.useMemo(() => {
    const activeItems = group.items.filter(item => item.isActive);
    const totalBaseValue = activeItems.reduce((sum, item) => sum + item.baseValue, 0);
    const totalScaledValue = activeItems.reduce((sum, item) => sum + item.scaledValue, 0);
    const totalChange = totalScaledValue - totalBaseValue;
    const totalPercentChange = totalBaseValue !== 0
      ? (totalChange / Math.abs(totalBaseValue)) * 100
      : 0;

    // Get top impact items (by absolute change)
    const topImpactItems = [...activeItems]
      .sort((a, b) => Math.abs(b.scaledValue - b.baseValue) - Math.abs(a.scaledValue - a.baseValue))
      .slice(0, 3);

    return {
      activeCount: activeItems.length,
      totalCount: group.items.length,
      totalBaseValue,
      totalScaledValue,
      totalChange,
      totalPercentChange,
      averageChange: activeItems.length > 0 ? totalChange / activeItems.length : 0,
      topImpactItems
    };
  }, [group.items]);

  // Handle group name change
  const handleNameChange = (e) => {
    setGroupName(e.target.value);
  };

  // Save group name change
  const saveNameChange = () => {
    if (groupName !== group.name) {
      onUpdate({
        ...group,
        name: groupName
      });

      addHistoryEntry({
        action: 'rename_scaling_group',
        description: `Renamed scaling group from "${group.name}" to "${groupName}"`
      });
    }

    setIsEditing(false);
  };

  // Handle item update
  const handleItemUpdate = (updatedItem) => {
    const updatedItems = group.items.map(item =>
      item.id === updatedItem.id ? updatedItem : item
    );

    onUpdate({
      ...group,
      items: updatedItems
    });
  };

  // Handle item drag start
  const handleItemDragStart = (e, item) => {
    setDraggedItem(item);
    e.dataTransfer.setData('application/json', JSON.stringify({
      groupId: group.id,
      itemId: item.id
    }));
    e.dataTransfer.effectAllowed = 'move';
  };

  // Handle item drag over
  const handleItemDragOver = (e, targetItem) => {
    e.preventDefault();
    if (draggedItem && draggedItem.id !== targetItem.id) {
      setDropTarget(targetItem);
    }
  };

  // Handle item drop
  const handleItemDrop = (e, targetItem) => {
    e.preventDefault();

    if (!draggedItem) return;

    // Get drag data
    const data = JSON.parse(e.dataTransfer.getData('application/json'));

    // If from the same group, reorder
    if (data.groupId === group.id) {
      const items = [...group.items];
      const draggedIndex = items.findIndex(item => item.id === draggedItem.id);
      const targetIndex = items.findIndex(item => item.id === targetItem.id);

      if (draggedIndex === -1 || targetIndex === -1) return;

      // Remove from original position and insert at new position
      const [removed] = items.splice(draggedIndex, 1);
      items.splice(targetIndex, 0, removed);

      onUpdate({
        ...group,
        items
      });

      addHistoryEntry({
        action: 'reorder_scaling_item',
        description: `Reordered scaling item "${draggedItem.label}" in group "${group.name}"`
      });
    }
    // If from another group, handle in parent component

    setDraggedItem(null);
    setDropTarget(null);
  };

  // Format number for display
  const formatNumber = (num) => {
    if (Math.abs(num) >= 1000000) {
      return (num / 1000000).toFixed(2) + 'M';
    } else if (Math.abs(num) >= 1000) {
      return (num / 1000).toFixed(2) + 'K';
    } else {
      return num.toFixed(2);
    }
  };

  // Handle group drag start
  const handleGroupDragStart = (e) => {
    e.dataTransfer.setData('application/json', JSON.stringify({
      type: 'group',
      groupId: group.id
    }));
    e.dataTransfer.effectAllowed = 'move';
  };

  return (
    <motion.div
      className={`advanced-scaling-group ${isProtected ? 'protected' : ''} ${isExpanded ? 'expanded' : 'collapsed'}`}
      ref={groupRef}
      initial={{ opacity: 0, height: 0 }}
      animate={{
        opacity: 1,
        height: 'auto'
      }}
      exit={{ opacity: 0, height: 0 }}
      layout
      draggable={!isProtected}
      onDragStart={handleGroupDragStart}
    >
      <div className="group-header" onClick={() => setIsExpanded(!isExpanded)}>
        <div className="header-left">
          <div className="expand-icon">
            {isExpanded ? '' : ''}
          </div>

          {isEditing ? (
            <div className="editing-name">
              <input
                type="text"
                value={groupName}
                onChange={handleNameChange}
                onBlur={saveNameChange}
                onKeyDown={e => e.key === 'Enter' && saveNameChange()}
                autoFocus
                onClick={e => e.stopPropagation()}
              />
            </div>
          ) : (
            <h3 className="group-name">
              {group.name}
              <button
                className="edit-name-button"
                onClick={e => {
                  e.stopPropagation();
                  setIsEditing(true);
                }}
                disabled={isProtected}
              >
                
              </button>
            </h3>
          )}

          <ValueTooltip
            itemId={group.items[0]?.id}
            showMatrix={true}
            position="right"
          >
            <div className="version-indicator">
              {group._scalingType || 'default'}
            </div>
          </ValueTooltip>
        </div>

        <div className="header-right">
          <div className="item-count">
            <span className="active-count">{stats.activeCount}</span>
            <span className="divider">/</span>
            <span className="total-count">{stats.totalCount}</span>
          </div>

          <button
            className="summary-button"
            onClick={e => {
              e.stopPropagation();
              setShowSummary(!showSummary);
            }}
            title="Toggle group summary"
          >
            
          </button>

          <button
            className="remove-button"
            onClick={e => {
              e.stopPropagation();
              onRemove(group.id);
            }}
            disabled={isProtected}
            title="Remove group"
          >
            
          </button>
        </div>
      </div>

      <AnimatePresence>
        {showSummary && (
          <motion.div
            className="group-summary"
            initial={{ opacity: 0, height: 0 }}
            animate={{ opacity: 1, height: 'auto' }}
            exit={{ opacity: 0, height: 0 }}
            onClick={e => e.stopPropagation()}
          >
            <div className="summary-stats">
              <div className="stat-item">
                <span className="stat-label">Total Change:</span>
                <span className={`stat-value ${stats.totalChange > 0 ? 'positive' : stats.totalChange < 0 ? 'negative' : ''}`}>
                  {formatNumber(stats.totalChange)}
                </span>
              </div>

              <div className="stat-item">
                <span className="stat-label">% Change:</span>
                <span className={`stat-value ${stats.totalPercentChange > 0 ? 'positive' : stats.totalPercentChange < 0 ? 'negative' : ''}`}>
                  {stats.totalPercentChange.toFixed(2)}%
                </span>
              </div>

              <div className="stat-item">
                <span className="stat-label">Average Change:</span>
                <span className={`stat-value ${stats.averageChange > 0 ? 'positive' : stats.averageChange < 0 ? 'negative' : ''}`}>
                  {formatNumber(stats.averageChange)}
                </span>
              </div>
            </div>

            <div className="top-impact-items">
              <h4>Top Impact Items</h4>
              <div className="impact-items-list">
                {stats.topImpactItems.map(item => (
                  <div key={item.id} className="impact-item">
                    <span className="item-label">{item.label}</span>
                    <span className={`item-change ${item.scaledValue > item.baseValue ? 'positive' : item.scaledValue < item.baseValue ? 'negative' : ''}`}>
                      {formatNumber(item.scaledValue - item.baseValue)}
                    </span>
                  </div>
                ))}

                {stats.topImpactItems.length === 0 && (
                  <div className="no-items">No active items</div>
                )}
              </div>
            </div>
          </motion.div>
        )}
      </AnimatePresence>

      <AnimatePresence>
        {isExpanded && (
          <motion.div
            className="group-items"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
          >
            {group.items.map(item => (
              <div
                key={item.id}
                className={`item-wrapper ${dropTarget?.id === item.id ? 'drop-target' : ''}`}
                draggable={!isProtected}
                onDragStart={e => handleItemDragStart(e, item)}
                onDragOver={e => handleItemDragOver(e, item)}
                onDrop={e => handleItemDrop(e, item)}
              >
                <EnhancedScalingItem
                  item={item}
                  onUpdate={handleItemUpdate}
                  showEfficacyTooltip={!isProtected}
                />
              </div>
            ))}

            {group.items.length === 0 && (
              <div className="no-items">
                No items in this group. Drag items here.
              </div>
            )}
          </motion.div>
        )}
      </AnimatePresence>
    </motion.div>
  );
};

export default AdvancedScalingGroup;
```

## Step 14: Create Integration Guide Documentation

```javascript
// src/components/Documentation/MatrixIntegrationGuide.js
import React, { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';

const MatrixIntegrationGuide = ({ onClose }) => {
  const [selectedSection, setSelectedSection] = useState('introduction');

  const sections = [
    { id: 'introduction', label: 'Introduction' },
    { id: 'versions-zones', label: 'Versions & Zones' },
    { id: 'efficacy', label: 'Efficacy Periods' },
    { id: 'scaling', label: 'Scaling System' },
    { id: 'calculations', label: 'Calculations' },
    { id: 'history', label: 'History Tracking' },
    { id: 'integration', label: 'CFA Integration' }
  ];

  return (
    <div className="matrix-integration-guide">
      <div className="guide-header">
        <h2>Matrix-Based System Integration Guide</h2>
        <button className="close-button" onClick={onClose}></button>
      </div>

      <div className="guide-content">
        <div className="guide-nav">
          {sections.map(section => (
            <button
              key={section.id}
              className={`nav-button ${selectedSection === section.id ? 'active' : ''}`}
              onClick={() => setSelectedSection(section.id)}
            >
              {section.label}
            </button>
          ))}
        </div>

        <div className="guide-section-content">
          <AnimatePresence mode="wait">
            <motion.div
              key={selectedSection}
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: -20 }}
              transition={{ duration: 0.3 }}
              className="section-content"
            >
              {selectedSection === 'introduction' && (
                <div className="section">
                  <h3>Introduction to the Matrix-Based System</h3>
                  <p>
                    The Matrix-Based System is a comprehensive approach to managing multiple versions
                    and zones of parameters within the ModEcon platform. This guide explains the key
                    concepts and integration points for developers working with the system.
                  </p>

                  <h4>Key Concepts</h4>
                  <ul>
                    <li><strong>Versions:</strong> Different financial scenarios or cases</li>
                    <li><strong>Zones:</strong> Geographical or market segments</li>
                    <li><strong>Efficacy Periods:</strong> Time ranges when parameters are active</li>
                    <li><strong>Matrix Structure:</strong> A multi-dimensional data structure that stores parameter values across versions and zones</li>
                    <li><strong>Scaling System:</strong> A system for applying modifications to parameters with cumulative effects</li>
                  </ul>

                  <div className="note">
                    <p>
                      The Matrix-Based System represents a fundamental shift from the previous approach,
                      treating scaling items as first-class citizens with the same capabilities as form values.
                    </p>
                  </div>
                </div>
              )}

              {selectedSection === 'versions-zones' && (
                <div className="section">
                  <h3>Versions & Zones</h3>
                  <p>
                    Versions and Zones provide a way to organize parameter values in a multi-dimensional matrix.
                  </p>

                  <h4>Versions</h4>
                  <p>
                    Versions represent different financial scenarios or cases. Each version can have:
                  </p>
                  <ul>
                    <li>A unique ID (e.g., "v1", "v2")</li>
                    <li>A display label (e.g., "Base Case", "High Growth")</li>
                    <li>A description</li>
                    <li>Creation and modification timestamps</li>
                    <li>An optional base version for inheritance</li>
                  </ul>

                  <h4>Zones</h4>
                  <p>
                    Zones represent geographical or market segments. Each zone can have:
                  </p>
                  <ul>
                    <li>A unique ID (e.g., "z1", "z2")</li>
                    <li>A display label (e.g., "Local", "Export")</li>
                    <li>A description</li>
                    <li>Creation timestamp</li>
                  </ul>

                  <h4>Matrix Structure</h4>
                  <p>
                    The matrix structure stores parameter values for each combination of version and zone:
                  </p>
                  <pre>
{`{
  "paramId": {
    "id": "paramId",
    "label": "Parameter Label",
    "type": "number",
    "versions": { "v1": {...}, "v2": {...} },
    "zones": { "z1": {...}, "z2": {...} },
    "matrix": {
      "v1": { "z1": 100, "z2": 120 },
      "v2": { "z1": 110, "z2": 130 }
    },
    "inheritance": {
      "v2": { "source": "v1", "percentage": 70 }
    }
  }
}`}
                  </pre>

                  <div className="note">
                    <p>
                      The active version and zone determine which parameter values are used in calculations.
                    </p>
                  </div>
                </div>
              )}

              {selectedSection === 'efficacy' && (
                <div className="section">
                  <h3>Efficacy Periods</h3>
                  <p>
                    Efficacy periods define when parameters are active during the simulation timeline.
                  </p>

                  <h4>Parameter Efficacy</h4>
                  <p>
                    Each parameter has an efficacy period with:
                  </p>
                  <ul>
                    <li>Start year (default: 0)</li>
                    <li>End year (default: plant lifetime)</li>
                    <li>Is customized flag</li>
                  </ul>

                  <h4>Scaling Item Efficacy</h4>
                  <p>
                    Scaling items have synchronized efficacy periods with their corresponding form values:
                  </p>
                  <pre>
{`{
  "item_paramId": {
    "type": "item",
    "id": "paramId",
    "groupId": "group-1",
    "start": 5,
    "end": 15,
    "isCustomized": true,
    "priority": "item",
    "formValueRef": "paramId"
  }
}`}
                  </pre>

                  <h4>Group Efficacy</h4>
                  <p>
                    Scaling groups can also have efficacy periods that can override item efficacy:
                  </p>
                  <pre>
{`{
  "group_group-1": {
    "type": "group",
    "id": "group-1",
    "name": "Scaling Group 1",
    "start": 0,
    "end": 20,
    "isCustomized": false,
    "overridesItems": false
  }
}`}
                  </pre>

                  <h4>Simulation Time</h4>
                  <p>
                    The current simulation time determines which parameters are active:
                  </p>
                  <pre>
{`// Check if parameter is active at current time
const isActive = simTime >= efficacy.start && simTime <= efficacy.end;

// Use effective value based on active state
const effectiveValue = isActive ? item.scaledValue : item.baseValue;`}
                  </pre>

                  <div className="note">
                    <p>
                      Efficacy periods enable time-sensitive financial modeling for parameters that are
                      only relevant during certain periods of the plant lifetime.
                    </p>
                  </div>
                </div>
              )}

              {selectedSection === 'scaling' && (
                <div className="section">
                  <h3>Scaling System</h3>
                  <p>
                    The enhanced scaling system treats scaling items as first-class citizens with the same
                    capabilities as form values.
                  </p>

                  <h4>Scaling Items</h4>
                  <p>
                    Scaling items now include:
                  </p>
                  <ul>
                    <li>Matrix-aware values based on version and zone</li>
                    <li>Efficacy periods for time-based activation</li>
                    <li>Enhanced tooltips for viewing detailed information</li>
                    <li>Improved visualization of scaling results</li>
                  </ul>

                  <h4>Cumulative Scaling</h4>
                  <p>
                    The system supports cumulative scaling across multiple groups:
                  </p>
                  <ol>
                    <li>Group 1 applies scaling to base values</li>
                    <li>Group 2 uses Group 1's results as its base values</li>
                    <li>This continues through the scaling chain</li>
                  </ol>

                  <h4>Synchronization</h4>
                  <p>
                    Scaling items are synchronized with form values:
                  </p>
                  <ul>
                    <li>Changes to form values propagate to scaling items</li>
                    <li>Efficacy period changes are synchronized in both directions</li>
                    <li>Scaling results are reflected in form values</li>
                  </ul>

                  <div className="note">
                    <p>
                      The enhanced scaling system provides a more intuitive and powerful way to
                      visualize and manage parameter modifications.
                    </p>
                  </div>
                </div>
              )}

              {selectedSection === 'calculations' && (
                <div className="section">
                  <h3>Calculations</h3>
                  <p>
                    The matrix-based system integrates with the calculation engine through
                    the CalSenMatrix service.
                  </p>

                  <h4>Configuration Matrix</h4>
                  <p>
                    The system generates a configuration matrix CSV based on efficacy periods:
                  </p>
                  <pre>
{`start,end,length,param1,param2,param3
0,4,5,1,0,1
5,10,6,1,1,1
11,15,5,1,1,0
16,20,5,1,0,0`}
                  </pre>

                  <h4>Calculation Flow</h4>
                  <p>
                    The calculation process involves these steps:
                  </p>
                  <ol>
                    <li>Synchronize form values with CalSenMatrix</li>
                    <li>Generate the configuration matrix CSV</li>
                    <li>Export paths for CFA calculation</li>
                    <li>Run baseline calculation</li>
                    <li>Configure sensitivity analysis</li>
                    <li>Run sensitivity calculations</li>
                  </ol>

                  <h4>Efficacy-Aware Calculations</h4>
                  <p>
                    CFA calculations now respect efficacy periods:
                  </p>
                  <pre>
{`// In CFA calculations
// Only apply parameter during its efficacy period
if (year >= param.efficacyPeriod.start && year <= param.efficacyPeriod.end) {
  // Apply parameter value to calculation
  result += param.effectiveValue * factor;
}`}
                  </pre>

                  <div className="note">
                    <p>
                      The integration with CFA enables powerful time-sensitive financial
                      modeling with version and zone awareness.
                    </p>
                  </div>
                </div>
              )}

              {selectedSection === 'history' && (
                <div className="section">
                  <h3>History Tracking</h3>
                  <p>
                    The system includes comprehensive history tracking for all state changes.
                  </p>

                  <h4>History Entries</h4>
                  <p>
                    Each history entry includes:
                  </p>
                  <ul>
                    <li>Unique ID</li>
                    <li>Timestamp</li>
                    <li>Action type</li>
                    <li>Description</li>
                    <li>Complete state snapshot</li>
                  </ul>

                  <h4>Tracked Actions</h4>
                  <p>
                    The system tracks various actions:
                  </p>
                  <ul>
                    <li>Creating/switching versions and zones</li>
                    <li>Updating parameter values</li>
                    <li>Changing efficacy periods</li>
                    <li>Modifying scaling groups</li>
                    <li>Running calculations</li>
                  </ul>

                  <h4>Undo/Redo</h4>
                  <p>
                    The history system enables undo/redo functionality:
                  </p>
                  <pre>
{`// Undo action
const undoAtom = atom(
  null,
  (get, set) => {
    const currentIndex = get(historyIndexAtom);
    if (currentIndex <= 0) return false;

    const newIndex = currentIndex - 1;
    const entries = get(historyEntriesAtom);
    const snapshot = entries[newIndex].snapshot;

    // Restore all state from snapshot
    set(formValuesMatrixAtom, snapshot.formMatrix);
    set(versionsAtom, snapshot.versions);
    set(zonesAtom, snapshot.zones);
    set(scalingGroupsAtom, snapshot.scalingGroups);
    set(extendedEfficacyPeriodsAtom, snapshot.efficacyPeriods);

    set(historyIndexAtom, newIndex);
    return true;
  }
);`}
                  </pre>

                  <div className="note">
                    <p>
                      The history tracking system provides a safety net for users and enables
                      advanced features like session playback.
                    </p>
                  </div>
                </div>
              )}

              {selectedSection === 'integration' && (
                <div className="section">
                  <h3>CFA Integration</h3>
                  <p>
                    The matrix-based system integrates with the CFA calculation engine.
                  </p>

                  <h4>CalSenMatrix Service</h4>
                  <p>
                    The CalSenMatrix service provides APIs for:
                  </p>
                  <ul>
                    <li>Storing and retrieving matrix-based parameter values</li>
                    <li>Managing versions and zones</li>
                    <li>Generating configuration matrices</li>
                    <li>Exporting paths for CFA calculation</li>
                  </ul>

                  <h4>Jotai-CalSen Synchronization</h4>
                  <p>
                    The Jotai state is synchronized with CalSenMatrix:
                  </p>
                  <pre>
{`// Sync with CalSen
const syncWithCalSen = async () => {
  setSyncStatus('syncing');

  try {
    const result = await synchronizeWithCalSen({
      versions,
      zones
    });

    if (result.success) {
      setSyncStatus('success');
    } else {
      setSyncStatus('error');
    }
  } catch (error) {
    setSyncStatus('error');
  }
};`}
                  </pre>

                  <h4>CFA Calculation Service</h4>
                  <p>
                    The calculation service integrates with CFA:
                  </p>
                  <pre>
{`// Run full sensitivity analysis
export const runFullSensitivityAnalysis = async (config) => {
  try {
    // Register payload
    const registerResult = await registerPayload({...});

    // Run baseline calculation
    const baselineResult = await runBaselineCalculation({...});

    // Configure sensitivity
    const configResult = await configureSensitivity({...});

    // Run sensitivity calculations
    const runsResult = await runSensitivityCalculations({...});

    return {
      success: true,
      message: 'Full sensitivity analysis completed successfully',
      phases: {
        register: registerResult,
        baseline: baselineResult,
        configure: configResult,
        runs: runsResult
      }
    };
  } catch (error) {
    return {
      success: false,
      message: \`Error running full sensitivity analysis: \${error.message}\`,
      error
    };
  }
};`}
                  </pre>

                  <div className="note">
                    <p>
                      The integration with CFA enables powerful financial modeling with
                      version, zone, and efficacy awareness.
                    </p>
                  </div>
                </div>
              )}
            </motion.div>
          </AnimatePresence>
        </div>
      </div>
    </div>
  );
};

export default MatrixIntegrationGuide;
```


## Implementation Sequence

To implement this system, follow this step-by-step approach:

1. **Set up the base project structure** with the necessary folders and dependencies
2. **Implement the matrix-based Jotai atoms** for form values, scaling items, and efficacy periods
3. **Create the CalSenMatrix service** to synchronize state between frontend and backend
4. **Develop the UI components** for matrix editing, version management, and scaling items
5. **Implement the calculation service** to integrate with the CFA calculation engine
6. **Connect all components** in the main App with proper synchronization

This architecture provides a complete system that:

1. Treats scaling items equally to form value baselines
2. Extends efficacy attributes to all components
3. Incorporates matrix-based version and zone management
4. Synchronizes state with CalSen for calculations
5. Provides tooltips and dialogs for viewing and editing calculated values
6. Maintains a comprehensive history of all state changes



1. **Unified State Management**
   - Treats scaling items equal to form value baselines
   - Provides consistent efficacy periods across all components
   - Manages versions and zones in a structured matrix

2. **Rich Visual Interactions**
   - Enhanced tooltips for immediate value insights
   - Comprehensive summaryItems visualization with multiple views
   - Interactive scaling groups with drag-and-drop reordering

3. **Time-Sensitive Modeling**
   - Efficacy periods enable time-based parameter activation
   - Simulation timeline slider for visualizing different time points
   - Configuration matrix generation for time-based calculations

4. **Comprehensive History**
   - Complete state history tracking for all components
   - Undo/redo functionality for all operations
   - Detailed history entries with timestamps and descriptions

5. **Seamless Integration**
   - Synchronization with CalSenMatrix service
   - Integration with CFA calculation engine
   - Comprehensive API for external systems

## Next Implementation Steps

To complete this implementation, follow these remaining steps:

1. **Styling and UI Polish**
   - Create CSS files for all new components
   - Ensure responsive design for different screen sizes
   - Add animations for smoother user experience

2. **Testing and Validation**
   - Create unit tests for all Jotai atoms and hooks
   - Develop integration tests for CalSen synchronization
   - Test with real-world financial models

3. **Documentation**
   - Complete API documentation for all components
   - Provide user guides with screenshots and examples
   - Create video tutorials for complex operations

4. **Deployment**
   - Set up CI/CD pipeline for automated testing and deployment
   - Configure environment-specific settings
   - Implement monitoring and logging

By following this implementation plan, you will create a powerful, modern, and user-friendly matrix-based system that fundamentally advances the capabilities of the ModEcon platform.

# ModEcon Matrix System Documentation

## API Documentation

### Matrix State Management System

The Matrix State Management System forms the architectural foundation of the ModEcon platform, providing a multi-dimensional approach to parameter management across versions, zones, and time periods. This system enables sophisticated financial modeling by treating all parameters as elements within a unified matrix structure.

#### Core Concepts

The system organizes data according to three primary dimensions:

1. **Versions**: Represent different financial scenarios or cases (e.g., Base Case, High Growth)
2. **Zones**: Represent geographical or market segments (e.g., Local, Export)
3. **Time Periods**: Represent phases during the simulation timeline when parameters are active

These dimensions combine to form a comprehensive matrix where each cell represents a parameter value for a specific version, zone, and time period. This structure enables powerful comparisons and sensitivity analyses.

#### Key Components

The Matrix State Management System comprises several interconnected modules:

- **Form Values Matrix**: Stores parameter values for each version-zone combination
- **Efficacy System**: Manages time-based activation of parameters
- **Scaling System**: Applies modifications to base values with cumulative effects
- **History Tracking**: Records all state changes for undo/redo functionality
- **CalSen Integration**: Synchronizes state with backend calculation services

#### API Structure

```
MatrixStateManager
 getState()  Object
 updateState(update_data)  {success, message}
 initialize_parameter(param_id, param_data)  Object
 get_parameter_value(param_id, version_id?, zone_id?)  value
 update_parameter_value(param_id, value, version_id?, zone_id?)  {success, message}
 update_efficacy_period(param_id, start, end, version_id?, zone_id?)  {success, message}
 create_version(label, description?, base_version?)  {version_id, message}
 create_zone(label, description?)  {zone_id, message}
 get_scaling_groups()  Array
 update_scaling_groups(scaling_groups)  {success, message}
 export_paths_for_calculation(version)  Object
```

#### Data Flow

1. Frontend components interact with Jotai atoms to manage state
2. State changes trigger synchronization with the CalSenMatrix service
3. CalSenMatrix translates matrix values into configuration files for CFA
4. CFA performs calculations and returns results to the frontend

#### Implementation Considerations

When extending the Matrix State Management System, developers should:

- Maintain version and zone integrity across all operations
- Ensure proper propagation of inheritance between versions
- Synchronize efficacy periods between form values and scaling items
- Add new actions to the history tracking system
- Update CalSen integration for any new parameters or structures

The system provides comprehensive API endpoints for all operations, enabling external integration with other services while maintaining data consistency across the platform.

### Form Values Matrix Module

The Form Values Matrix Module provides a sophisticated data structure for storing and manipulating parameter values across multiple versions and zones. This module forms the heart of the matrix-based approach, enabling parallel financial modeling scenarios.

#### Matrix Structure

Each parameter in the system is represented by a matrix object with the following structure:

```javascript
{
  id: "paramId",
  label: "Parameter Label",
  type: "number",
  versions: {
    "v1": { label: "Base Case", isActive: true },
    "v2": { label: "High Growth", isActive: false }
  },
  zones: {
    "z1": { label: "Local", isActive: true },
    "z2": { label: "Export", isActive: false }
  },
  matrix: {
    "v1": { "z1": 100, "z2": 120 },
    "v2": { "z1": 110, "z2": 130 }
  },
  inheritance: {
    "v2": { source: "v1", percentage: 70 }
  },
  efficacyPeriod: {
    start: { value: 0 },
    end: { value: 20 }
  },
  dynamicAppendix: {
    // Scaling and grouping metadata
  }
}
```

#### Key Atoms

```javascript
// Main atoms
export const versionsAtom = atom({list, active, metadata});
export const zonesAtom = atom({list, active, metadata});
export const formValuesMatrixAtom = atom({});

// Initialization and operations
export const initializeFormValueMatrixAtom = atom(null, (get, set) => {...});
export const getCurrentValueAtom = atom((get) => (paramId) => {...});
export const updateMatrixValueAtom = atom(null, (get, set, {paramId, versionId, zoneId, value}) => {...});
export const configureInheritanceAtom = atom(null, (get, set, {paramId, versionId, sourceVersionId, percentage}) => {...});
```

#### Version Management

Versions represent different financial scenarios and can inherit values from other versions. Each version has:

- Unique identifier (e.g., "v1", "v2")
- Display label (e.g., "Base Case", "High Growth")
- Metadata (description, creation timestamp)
- Inheritance configuration (source version, percentage)

The system supports creating, activating, and configuring versions. When inheritance is configured, changes to the source version automatically propagate to dependent versions according to the specified percentage.

#### Zone Management

Zones represent geographical or market segments, each with its own parameter values. Each zone has:

- Unique identifier (e.g., "z1", "z2")
- Display label (e.g., "Local", "Export")
- Metadata (description, creation timestamp)

The system supports creating, activating, and managing zones. Parameter values are stored independently for each zone, allowing region-specific financial modeling.

#### Integration Points

The Form Values Matrix Module integrates with:

- **UI Components**: Through Jotai atoms and selectors
- **Efficacy System**: By storing efficacy periods for each parameter
- **Scaling System**: By providing base values for scaling operations
- **History Tracking**: By recording all matrix value changes
- **CalSen Service**: By synchronizing matrix state with backend services

Developers working with this module should ensure proper version and zone management, maintain inheritance relationships, and synchronize state changes across all components of the system.

### Efficacy System

The Efficacy System enables time-sensitive financial modeling by managing the activation periods of parameters throughout the simulation timeline. This system ensures that parameters only affect calculations during their designated efficacy periods, providing more realistic modeling of changing conditions over time.

#### Core Structure

The efficacy system assigns time periods to parameters and scaling items:

```javascript
// Parameter efficacy
{
  "paramId": {
    efficacyPeriod: {
      start: { value: 5 },  // Start year
      end: { value: 15 }    // End year
    }
  }
}

// Scaling item efficacy
{
  "item_paramId": {
    type: "item",
    id: "paramId",
    groupId: "group-1",
    start: 5,               // Start year
    end: 15,                // End year
    isCustomized: true,
    priority: "item",
    formValueRef: "paramId"
  }
}

// Group efficacy
{
  "group_group-1": {
    type: "group",
    id: "group-1",
    name: "Scaling Group 1",
    start: 0,
    end: 20,
    isCustomized: false,
    overridesItems: false   // Whether group efficacy overrides item efficacy
  }
}
```

#### Key Atoms

```javascript
// Initialize efficacy periods
export const extendedEfficacyPeriodsAtom = atom({});
export const initializeEfficacyPeriodsAtom = atom(null, (get, set) => {...});

// Update efficacy periods
export const updateScalingItemEfficacyAtom = atom(null, (get, set, {itemId, start, end, syncToFormValue, syncFromFormValue, priority}) => {...});

// Query efficacy-aware scaling groups
export const efficacyAwareScalingGroupsAtom = atom((get) => {...});

// Simulation time
export const simulationTimeAtom = atom(0);
```

#### Time-Based Activation

The system determines which parameters are active at any given simulation time:

```javascript
// Check if parameter is active at current time
const isActive = simTime >= efficacy.start && simTime <= efficacy.end;

// Use effective value based on active state
const effectiveValue = isActive ? item.scaledValue : item.baseValue;
```

When a parameter is inactive, its base value is used instead of its scaled value, ensuring that scaling effects only apply during the designated efficacy period.

#### Synchronization

The Efficacy System synchronizes efficacy periods between:

- Form values and scaling items: Changes to form value efficacy propagate to corresponding scaling items
- Scaling items and form values: Changes to scaling item efficacy can optionally update form values
- Groups and items: Group efficacy can optionally override item efficacy

This synchronization ensures consistency across all system components, maintaining a coherent time-based model.

#### Configuration Matrix Generation

The system generates a configuration matrix CSV showing which parameters are active during which time periods:

```csv
start,end,length,param1,param2,param3
0,4,5,1,0,1
5,10,6,1,1,1
11,15,5,1,1,0
16,20,5,1,0,0
```

This matrix is used by the calculation engine to correctly apply parameters during their active periods, ensuring that financial models accurately reflect time-based changes.

#### Integration Points

The Efficacy System integrates with:
- Form Values Matrix: Using efficacy periods stored in the matrix
- Scaling System: Applying efficacy to scaling items
- Calculation Engine: Generating configuration matrices for time-based calculations
- UI Components: Enabling visualization and editing of efficacy periods

### Scaling System

The Scaling System provides a powerful mechanism for modifying parameter values through a series of scaling operations. It treats scaling items as first-class citizens with the same capabilities as form values, enabling sophisticated financial modeling techniques.

#### Scaling Groups and Items

Scaling is organized into groups, each containing items that correspond to parameters:

```javascript
{
  id: "group-1",
  name: "Base Scaling",
  _scalingType: "percentage",
  isProtected: false,
  items: [
    {
      id: "paramId",
      label: "Parameter Label",
      originalBaseValue: 100,   // Original parameter value
      baseValue: 100,           // Current base value (may come from previous group)
      scalingFactor: 1.2,       // Factor to apply
      operation: "multiply",    // Operation to perform
      enabled: true,            // Whether scaling is enabled
      notes: "Sample note",     // User notes
      scaledValue: 120,         // Result of scaling operation
      vKey: null,               // Optional V reference
      rKey: null                // Optional R reference
    }
  ]
}
```

#### Cumulative Scaling Chain

The system supports cumulative scaling across multiple groups:

1. Group 1 applies scaling to original base values
2. Group 2 uses Group 1's results as its base values
3. This continues through the scaling chain
4. Final results reflect the cumulative effect of all scaling operations

This approach enables staged modifications with clear visualization of each step's impact.

#### Key Components

The Scaling System includes:

- **AdvancedScalingGroup**: Manages a collection of scaling items with group-level operations
- **EnhancedScalingItem**: Individual scaling item with matrix and efficacy awareness
- **EnhancedSummaryPanel**: Visualizes scaling results with multiple views
- **DraggableScalingItem**: Enables drag-and-drop reordering of items
- **CumulativeDocumentation**: Explains cumulative scaling concepts

#### Operations

The system supports multiple scaling operations:

- **Multiply**: `baseValue * factor`
- **Add**: `baseValue + factor`
- **Subtract**: `baseValue - factor`
- **Divide**: `baseValue / factor`
- **Power**: `baseValue ^ factor`
- **Logarithmic**: `ln(baseValue) * factor`
- **Exponential**: `e^(ln(baseValue) * factor)`

Each operation can be applied to any parameter, with real-time visualization of the results.

#### Advanced Features

The Scaling System includes advanced features:

- **Efficacy Integration**: Scaling items respect efficacy periods
- **Matrix Awareness**: Items use values from active version and zone
- **Protection**: Groups can be protected from changes
- **History Tracking**: All scaling operations are recorded for undo/redo
- **Import/Export**: Configuration can be saved and loaded
- **Visualization**: Multiple views and charts for result analysis

#### Integration Points

The Scaling System integrates with:

- **Form Values Matrix**: Using base values from the matrix
- **Efficacy System**: Applying time-based activation to scaling items
- **History Tracking**: Recording all scaling operations
- **CalSen Service**: Synchronizing scaling results for calculations
- **UI Components**: Providing interactive visualization and editing

Developers extending the Scaling System should ensure proper propagation of changes through the cumulative chain, synchronization with form values, and respect for efficacy periods in all operations.

### History Tracking

The History Tracking system provides comprehensive state management with undo/redo capabilities for all operations in the ModEcon platform. It captures detailed snapshots of the entire application state at each step, enabling users to navigate through their work history and recover from mistakes.

Key features include:
- Complete state snapshots for reliable restoration
- Detailed metadata for each history entry
- Support for undo/redo across all system components
- Exportable history for session persistence
- Integration with all matrix operations

The system uses Jotai atoms to manage history entries and index position, providing a clean API for adding entries and navigating through history. When implementing new components, developers should ensure all state-changing operations are recorded in the history system to maintain a complete audit trail and enable full undo/redo functionality.

### Calculation Integration

The Calculation Integration module connects the matrix-based system with the CFA calculation engine, enabling sophisticated financial modeling with version, zone, and efficacy awareness. This module translates the matrix state into configuration files for CFA, runs calculations, and processes results for visualization.

The system provides a complete calculation workflow including baseline calculations, sensitivity configuration, and sensitivity analysis runs. It synchronizes with CalSenMatrix to ensure all parameter values are correctly represented in the calculation engine. Developers integrating with this module should ensure proper synchronization of state before calculations and handle calculation results appropriately in the UI components.

### MatrixControls Component

The MatrixControls component provides a user interface for managing versions and zones within the matrix system. It displays active versions and zones, allows switching between them, and provides functionality to create new versions and zones. The component integrates with the versionsAtom and zonesAtom to maintain synchronization with the global state, and includes confirmation dialogs for creating new versions with optional inheritance from existing versions.

### MatrixEditDialog Component

The MatrixEditDialog component enables editing of matrix values for a specific parameter across versions and zones. It displays a grid of values with the currently selected version and zone highlighted, and provides inline editing capabilities. The dialog integrates with the formValuesMatrixAtom, versionsAtom, and zonesAtom to maintain synchronization with the global state, and includes inheritance information to show relationships between versions.

### EnhancedScalingItem Component

The EnhancedScalingItem component represents an individual scaling item with matrix and efficacy awareness. It displays the item's base value, scaled value, and efficacy period, and provides controls for modifying the scaling factor and operation. The component integrates with the efficacyPeriodsAtom to respect time-based activation, and includes tooltips for viewing detailed information about the scaling calculation.

### AdvancedScalingGroup Component

The AdvancedScalingGroup component manages a collection of scaling items with group-level operations. It displays group statistics including total impact and active item count, and provides controls for expanding/collapsing the group, editing the group name, and removing the group. The component supports drag-and-drop reordering of items within the group and displays a summary of the top impact items when requested.

### EnhancedSummaryPanel Component

The EnhancedSummaryPanel component visualizes scaling results with multiple views including compact table, detailed items, and chart visualization. It provides filtering, sorting, and search capabilities for analyzing scaling impacts, and includes statistical information about the overall scaling effects. The component integrates with the efficacyAwareScalingGroupsAtom and simulationTimeAtom to show time-specific results.

### ValueTooltip Component

The ValueTooltip component provides rich contextual information about parameter values when hovering over elements in the user interface. It shows base value, scaled value, effective value, and change statistics in a formatted tooltip that automatically positions itself relative to the trigger element. The component supports customization of display content, position, and size, and integrates with the matrix system to show version and zone-specific information.

### MatrixIntegrationGuide Component

The MatrixIntegrationGuide component provides interactive documentation about the matrix-based system for developers and advanced users. It includes sections on key concepts, versions and zones, efficacy periods, scaling system, calculations, history tracking, and CFA integration. The guide uses animated transitions between sections and provides code examples and visual diagrams to explain complex concepts.

## Styling and UI Polish

### Matrix System Core Styles (matrix-core.css)

```css
/* Primary styling for matrix-based components */
.matrix-container {
  --matrix-primary: #2c5282;
  --matrix-secondary: #4299e1;
  --matrix-accent: #f6ad55;
  --matrix-bg-primary: #f7fafc;
  --matrix-bg-secondary: #edf2f7;
  --matrix-text-primary: #1a202c;
  --matrix-text-secondary: #4a5568;
  --matrix-border: #e2e8f0;
  --matrix-success: #48bb78;
  --matrix-error: #f56565;
  --matrix-warning: #ed8936;
  --matrix-positive: #38a169;
  --matrix-negative: #e53e3e;
  --matrix-neutral: #718096;
  --matrix-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);

  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  color: var(--matrix-text-primary);
  box-sizing: border-box;
}

.matrix-container *,
.matrix-container *::before,
.matrix-container *::after {
  box-sizing: inherit;
}

/* Layout components */
.matrix-layout {
  display: grid;
  grid-template-columns: 280px 1fr;
  grid-template-rows: auto 1fr;
  grid-template-areas:
    "header header"
    "sidebar content";
  height: 100vh;
  width: 100%;
  overflow: hidden;
}

.matrix-header {
  grid-area: header;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0.75rem 1.25rem;
  background-color: var(--matrix-primary);
  color: white;
  box-shadow: var(--matrix-shadow);
  z-index: 10;
}

.matrix-sidebar {
  grid-area: sidebar;
  background-color: var(--matrix-bg-secondary);
  border-right: 1px solid var(--matrix-border);
  padding: 1rem;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.matrix-content {
  grid-area: content;
  padding: 1.5rem;
  overflow-y: auto;
  background-color: var(--matrix-bg-primary);
}

/* Panel components */
.matrix-panel {
  background-color: white;
  border-radius: 0.5rem;
  box-shadow: var(--matrix-shadow);
  overflow: hidden;
  margin-bottom: 1.5rem;
}

.panel-header {
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--matrix-border);
  display: flex;
  align-items: center;
  justify-content: space-between;
  background-color: var(--matrix-bg-secondary);
}

.panel-title {
  font-size: 1.125rem;
  font-weight: 600;
  color: var(--matrix-primary);
  margin: 0;
}

.panel-content {
  padding: 1.25rem;
}

/* Button styles */
.matrix-btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 0.5rem 1rem;
  border-radius: 0.375rem;
  font-size: 0.875rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  border: none;
  outline: none;
}

.matrix-btn-primary {
  background-color: var(--matrix-primary);
  color: white;
}

.matrix-btn-primary:hover {
  background-color: #1e4069;
}

.matrix-btn-secondary {
  background-color: var(--matrix-bg-secondary);
  color: var(--matrix-text-primary);
  border: 1px solid var(--matrix-border);
}

.matrix-btn-secondary:hover {
  background-color: #e2e8f0;
}

.matrix-btn-accent {
  background-color: var(--matrix-accent);
  color: var(--matrix-text-primary);
}

.matrix-btn-accent:hover {
  background-color: #f69337;
}

.matrix-btn-icon {
  padding: 0.5rem;
  border-radius: 0.375rem;
}

/* Form controls */
.matrix-input {
  display: block;
  width: 100%;
  padding: 0.5rem 0.75rem;
  font-size: 0.875rem;
  line-height: 1.5;
  color: var(--matrix-text-primary);
  background-color: white;
  border: 1px solid var(--matrix-border);
  border-radius: 0.375rem;
  transition: border-color 0.2s ease;
}

.matrix-input:focus {
  border-color: var(--matrix-secondary);
  outline: none;
  box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.2);
}

.matrix-select {
  display: block;
  width: 100%;
  padding: 0.5rem 2rem 0.5rem 0.75rem;
  font-size: 0.875rem;
  line-height: 1.5;
  color: var(--matrix-text-primary);
  background-color: white;
  background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='none'%3E%3Cpath d='M7 7l3 3 3-3' stroke='%234a5568' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
  background-position: right 0.5rem center;
  background-repeat: no-repeat;
  background-size: 1.5em 1.5em;
  border: 1px solid var(--matrix-border);
  border-radius: 0.375rem;
  appearance: none;
}

.matrix-select:focus {
  border-color: var(--matrix-secondary);
  outline: none;
  box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.2);
}

.matrix-label {
  display: block;
  font-size: 0.875rem;
  font-weight: 500;
  color: var(--matrix-text-secondary);
  margin-bottom: 0.5rem;
}

.matrix-checkbox {
  display: flex;
  align-items: center;
}

.matrix-checkbox input[type="checkbox"] {
  height: 1rem;
  width: 1rem;
  border-radius: 0.25rem;
  border: 1px solid var(--matrix-border);
  margin-right: 0.5rem;
}

/* Responsive breakpoints */
@media (max-width: 768px) {
  .matrix-layout {
    grid-template-columns: 1fr;
    grid-template-rows: auto auto 1fr;
    grid-template-areas:
      "header"
      "sidebar"
      "content";
  }

  .matrix-sidebar {
    border-right: none;
    border-bottom: 1px solid var(--matrix-border);
    padding: 0.75rem;
  }
}

@media (max-width: 480px) {
  .matrix-header {
    flex-direction: column;
    align-items: flex-start;
    gap: 0.5rem;
    padding: 0.5rem 1rem;
  }

  .panel-header {
    flex-direction: column;
    align-items: flex-start;
    gap: 0.5rem;
  }
}
```

### Matrix Controls Styles (matrix-controls.css)

```css
/* Matrix Controls Component Styles */
.matrix-controls {
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
  width: 100%;
}

.matrix-selector {
  display: flex;
  flex-direction: column;
  gap: 1rem;
  width: 100%;
}

.version-selector,
.zone-selector {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.selector-items {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
}

.selector-item {
  padding: 0.5rem 0.75rem;
  border-radius: 0.375rem;
  font-size: 0.875rem;
  cursor: pointer;
  transition: all 0.2s ease;
  background-color: white;
  border: 1px solid var(--matrix-border);
  flex: 1 1 calc(50% - 0.25rem);
  min-width: 100px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.selector-item.active {
  background-color: var(--matrix-primary);
  color: white;
  border-color: var(--matrix-primary);
}

.selector-item:hover:not(.active) {
  background-color: var(--matrix-bg-secondary);
}

.add-item {
  background-color: var(--matrix-bg-secondary);
  color: var(--matrix-primary);
  border: 1px dashed var(--matrix-border);
}

.add-item:hover {
  background-color: var(--matrix-bg-primary);
  border-color: var(--matrix-secondary);
}

.sync-status {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0.5rem;
  font-size: 0.875rem;
  color: var(--matrix-neutral);
}

.sync-status .syncing {
  color: var(--matrix-neutral);
  animation: pulse 1.5s infinite;
}

.sync-status .success {
  color: var(--matrix-success);
}

.sync-status .error {
  color: var(--matrix-error);
}

/* Dialog styling */
.dialog-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 50;
}

.dialog {
  background-color: white;
  border-radius: 0.5rem;
  box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
  width: 90%;
  max-width: 500px;
  max-height: 90vh;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
}

.dialog-header {
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--matrix-border);
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.dialog-header h3 {
  margin: 0;
  font-size: 1.125rem;
  font-weight: 600;
}

.dialog-header button {
  background: none;
  border: none;
  font-size: 1.5rem;
  cursor: pointer;
  color: var(--matrix-text-secondary);
}

.dialog-content {
  padding: 1.25rem;
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.dialog-actions {
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--matrix-border);
  display: flex;
  align-items: center;
  justify-content: flex-end;
  gap: 0.75rem;
}

.input-group {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.help-text {
  font-size: 0.75rem;
  color: var(--matrix-text-secondary);
  margin-top: 0.25rem;
}

/* Animation for syncing indicator */
@keyframes pulse {
  0% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
  100% {
    opacity: 1;
  }
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .matrix-selector {
    flex-direction: column;
  }

  .selector-item {
    flex: 1 1 calc(33.333% - 0.333rem);
  }
}

@media (max-width: 480px) {
  .selector-item {
    flex: 1 1 100%;
  }

  .dialog {
    width: 95%;
  }
}
```

### Enhanced Scaling Styles (enhanced-scaling.css)

```css
/* Enhanced Scaling Component Styles */
.enhanced-scaling-container {
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
  width: 100%;
}

/* Scaling Group */
.advanced-scaling-group {
  background-color: white;
  border-radius: 0.5rem;
  box-shadow: var(--matrix-shadow);
  overflow: hidden;
  border-left: 4px solid var(--matrix-primary);
  transition: all 0.3s ease;
}

.advanced-scaling-group.protected {
  border-left-color: var(--matrix-warning);
}

.group-header {
  padding: 0.75rem 1rem;
  background-color: var(--matrix-bg-secondary);
  border-bottom: 1px solid var(--matrix-border);
  display: flex;
  align-items: center;
  justify-content: space-between;
  cursor: pointer;
  transition: background-color 0.2s ease;
}

.group-header:hover {
  background-color: #e2e8f0;
}

.header-left {
  display: flex;
  align-items: center;
  gap: 0.75rem;
}

.expand-icon {
  font-size: 0.75rem;
  color: var(--matrix-text-secondary);
  transition: transform 0.2s ease;
}

.collapsed .expand-icon {
  transform: rotate(-90deg);
}

.group-name {
  margin: 0;
  font-size: 1rem;
  font-weight: 600;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.edit-name-button {
  background: none;
  border: none;
  font-size: 0.875rem;
  padding: 0.125rem 0.25rem;
  color: var(--matrix-text-secondary);
  cursor: pointer;
  opacity: 0.5;
  transition: opacity 0.2s ease;
}

.edit-name-button:hover {
  opacity: 1;
}

.editing-name input {
  font-size: 1rem;
  font-weight: 600;
  padding: 0.25rem 0.5rem;
  border: 1px solid var(--matrix-secondary);
  border-radius: 0.25rem;
  outline: none;
}

.version-indicator {
  font-size: 0.75rem;
  padding: 0.125rem 0.375rem;
  background-color: var(--matrix-bg-primary);
  border: 1px solid var(--matrix-border);
  border-radius: 1rem;
  color: var(--matrix-text-secondary);
}

.header-right {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.item-count {
  font-size: 0.75rem;
  color: var(--matrix-text-secondary);
  display: flex;
  align-items: center;
}

.active-count {
  font-weight: 600;
  color: var(--matrix-success);
}

.divider {
  margin: 0 0.25rem;
}

.total-count {
  color: var(--matrix-text-secondary);
}

.summary-button,
.remove-button {
  background: none;
  border: none;
  font-size: 1rem;
  padding: 0.25rem;
  cursor: pointer;
  border-radius: 0.25rem;
  transition: all 0.2s ease;
}

.summary-button:hover {
  background-color: var(--matrix-bg-primary);
  color: var(--matrix-primary);
}

.remove-button:hover {
  background-color: var(--matrix-bg-primary);
  color: var(--matrix-error);
}

.group-summary {
  padding: 1rem;
  background-color: #f8fafc;
  border-bottom: 1px solid var(--matrix-border);
}

.summary-stats {
  display: flex;
  flex-wrap: wrap;
  gap: 1rem;
  margin-bottom: 1rem;
}

.stat-item {
  display: flex;
  flex-direction: column;
  flex: 1 1 calc(33.333% - 0.667rem);
  min-width: 120px;
}

.stat-label {
  font-size: 0.75rem;
  color: var(--matrix-text-secondary);
  margin-bottom: 0.25rem;
}

.stat-value {
  font-size: 1rem;
  font-weight: 600;
}

.stat-value.positive {
  color: var(--matrix-positive);
}

.stat-value.negative {
  color: var(--matrix-negative);
}

.top-impact-items h4 {
  font-size: 0.875rem;
  margin: 0 0 0.5rem 0;
  color: var(--matrix-text-secondary);
}

.impact-items-list {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.impact-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  background-color: white;
  padding: 0.5rem 0.75rem;
  border-radius: 0.375rem;
  border: 1px solid var(--matrix-border);
}

.item-label {
  font-size: 0.875rem;
}

.item-change {
  font-size: 0.875rem;
  font-weight: 600;
}

.item-change.positive {
  color: var(--matrix-positive);
}

.item-change.negative {
  color: var(--matrix-negative);
}

.no-items {
  font-size: 0.875rem;
  color: var(--matrix-text-secondary);
  font-style: italic;
  padding: 0.5rem 0;
}

.group-items {
  padding: 1rem;
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}

.item-wrapper {
  position: relative;
  transition: all 0.2s ease;
  border-radius: 0.375rem;
}

.item-wrapper.drop-target {
  box-shadow: 0 0 0 2px var(--matrix-secondary);
}

/* Enhanced Scaling Item */
.scaling-item {
  background-color: white;
  border-radius: 0.375rem;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  padding: 0.75rem;
  border: 1px solid var(--matrix-border);
  transition: all 0.2s ease;
}

.scaling-item:hover {
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

.scaling-item.active {
  border-left: 3px solid var(--matrix-success);
}

.scaling-item.inactive {
  border-left: 3px solid var(--matrix-neutral);
  opacity: 0.7;
}

.scaling-item-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 0.5rem;
}

.item-label {
  font-size: 0.875rem;
  font-weight: 500;
}

.item-badges {
  display: flex;
  gap: 0.5rem;
}

.efficacy-badge,
.scaled-badge {
  font-size: 0.6875rem;
  padding: 0.125rem 0.375rem;
  border-radius: 1rem;
  cursor: pointer;
}

.efficacy-badge {
  background-color: #ebf8ff;
  color: #2c5282;
  border: 1px solid #bee3f8;
}

.scaled-badge {
  background-color: #f0fff4;
  color: #276749;
  border: 1px solid #c6f6d5;
}

.scaling-item-controls {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 1rem;
}

.scaling-factor-group {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.scaling-factor-input {
  width: 5rem;
  padding: 0.375rem 0.5rem;
  font-size: 0.875rem;
  border: 1px solid var(--matrix-border);
  border-radius: 0.25rem;
}

.operation-select {
  padding: 0.375rem;
  font-size: 0.875rem;
  border: 1px solid var(--matrix-border);
  border-radius: 0.25rem;
  background-color: var(--matrix-bg-secondary);
}

.scaled-value-group {
  display: flex;
  flex-direction: column;
  font-size: 0.75rem;
  color: var(--matrix-text-secondary);
}

.base-value {
  margin-bottom: 0.25rem;
}

.scaled-value {
  font-weight: 600;
  color: var(--matrix-text-primary);
}

/* Efficacy dialog */
.efficacy-dialog {
  position: absolute;
  top: calc(100% + 5px);
  left: 0;
  right: 0;
  background-color: white;
  border-radius: 0.375rem;
  box-shadow: 0 10px 15px rgba(0, 0, 0, 0.15);
  border: 1px solid var(--matrix-border);
  z-index: 10;
}

.dialog-header {
  padding: 0.75rem;
  border-bottom: 1px solid var(--matrix-border);
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.dialog-header h3 {
  margin: 0;
  font-size: 0.875rem;
  font-weight: 600;
}

.dialog-header button {
  background: none;
  border: none;
  font-size: 1.25rem;
  cursor: pointer;
  color: var(--matrix-text-secondary);
}

.dialog-content {
  padding: 0.75rem;
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}

.input-group {
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
}

.input-group label {
  font-size: 0.75rem;
  color: var(--matrix-text-secondary);
}

.input-group input {
  padding: 0.375rem 0.5rem;
  font-size: 0.875rem;
  border: 1px solid var(--matrix-border);
  border-radius: 0.25rem;
}

.reset-button {
  background-color: var(--matrix-bg-secondary);
  border: 1px solid var(--matrix-border);
  border-radius: 0.25rem;
  padding: 0.375rem 0.75rem;
  font-size: 0.75rem;
  cursor: pointer;
  align-self: flex-end;
}

/* Scaled value tooltip */
.scaled-value-tooltip {
  position: absolute;
  top: calc(100% + 5px);
  left: 0;
  right: 0;
  background-color: white;
  border-radius: 0.375rem;
  box-shadow: 0 10px 15px rgba(0, 0, 0, 0.15);
  border: 1px solid var(--matrix-border);
  z-index: 10;
}

.tooltip-header {
  padding: 0.75rem;
  border-bottom: 1px solid var(--matrix-border);
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.tooltip-header h4 {
  margin: 0;
  font-size: 0.875rem;
  font-weight: 600;
}

.tooltip-content {
  padding: 0.75rem;
}

.detail-row {
  display: flex;
  justify-content: space-between;
  padding: 0.375rem 0;
  font-size: 0.8125rem;
  border-bottom: 1px solid var(--matrix-border);
}

.detail-row:last-child {
  border-bottom: none;
}

.detail-label {
  color: var(--matrix-text-secondary);
}

.detail-value {
  font-weight: 500;
}

.detail-value.positive {
  color: var(--matrix-positive);
}

.detail-value.negative {
  color: var(--matrix-negative);
}

.detail-value.highlight {
  color: var(--matrix-primary);
  font-weight: 600;
}

/* Animation for scaling item */
@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.scaling-item {
  animation: fadeIn 0.3s ease;
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .summary-stats {
    flex-direction: column;
    gap: 0.75rem;
  }

  .stat-item {
    flex: 1 1 100%;
  }

  .scaling-item-controls {
    flex-direction: column;
    align-items: flex-start;
    gap: 0.75rem;
  }

  .scaling-factor-group {
    width: 100%;
  }

  .scaling-factor-input {
    flex: 1;
  }
}

@media (max-width: 480px) {
  .group-header {
    flex-direction: column;
    align-items: flex-start;
    gap: 0.5rem;
  }

  .header-right {
    width: 100%;
    justify-content: space-between;
  }
}
```

### Summary Panel Styles (summary-panel.css)

```css
/* Enhanced Summary Panel Styles */
.enhanced-summary-panel {
  background-color: white;
  border-radius: 0.5rem;
  box-shadow: var(--matrix-shadow);
  overflow: hidden;
  margin-top: 1.5rem;
}

.summary-header {
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--matrix-border);
  background-color: var(--matrix-bg-secondary);
}

.summary-header h3 {
  margin: 0 0 0.75rem 0;
  font-size: 1.125rem;
  font-weight: 600;
  color: var(--matrix-primary);
}

.summary-controls {
  display: flex;
  flex-wrap: wrap;
  gap: 1rem;
  align-items: center;
}

.search-control {
  flex: 1;
  min-width: 200px;
}

.search-input {
  width: 100%;
  padding: 0.5rem 0.75rem;
  border: 1px solid var(--matrix-border);
  border-radius: 0.375rem;
  font-size: 0.875rem;
  background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='none'%3E%3Cpath d='M17.5 17.5l-5-5m-4 1a5 5 0 110-10 5 5 0 010 10z' stroke='%234a5568' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
  background-position: left 0.75rem center;
  background-repeat: no-repeat;
  background-size: 1em 1em;
  padding-left: 2.5rem;
}

.filter-control {
  display: flex;
  align-items: center;
}

.filter-label {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-size: 0.875rem;
  cursor: pointer;
}

.filter-checkbox {
  width: 1rem;
  height: 1rem;
}

.view-control {
  display: flex;
  align-items: center;
  gap: 0.25rem;
}

.view-button {
  padding: 0.375rem 0.5rem;
  background: none;
  border: 1px solid var(--matrix-border);
  border-radius: 0.25rem;
  cursor: pointer;
  transition: all 0.2s ease;
}

.view-button.active {
  background-color: var(--matrix-primary);
  color: white;
  border-color: var(--matrix-primary);
}

.view-button:hover:not(.active) {
  background-color: var(--matrix-bg-secondary);
}

.simulation-control {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  margin-left: auto;
}

.sim-label {
  font-size: 0.75rem;
  color: var(--matrix-text-secondary);
}

.sim-slider {
  width: 8rem;
}

.sim-value {
  font-size: 0.875rem;
  font-weight: 600;
  color: var(--matrix-primary);
  min-width: 1.5rem;
  text-align: right;
}

.summary-stats {
  display: flex;
  flex-wrap: wrap;
  gap: 1rem;
  padding: 1rem 1.25rem;
  background-color: #f8fafc;
  border-bottom: 1px solid var(--matrix-border);
}

.stat-item {
  display: flex;
  flex-direction: column;
  flex: 1 1 calc(25% - 0.75rem);
  min-width: 120px;
}

.stat-label {
  font-size: 0.75rem;
  color: var(--matrix-text-secondary);
  margin-bottom: 0.25rem;
}

.stat-value {
  font-size: 1rem;
  font-weight: 600;
}

.stat-value.positive {
  color: var(--matrix-positive);
}

.stat-value.negative {
  color: var(--matrix-negative);
}

/* Summary table (compact view) */
.summary-table {
  width: 100%;
  border-collapse: collapse;
}

.summary-table th,
.summary-table td {
  padding: 0.75rem;
  text-align: left;
  font-size: 0.875rem;
  border-bottom: 1px solid var(--matrix-border);
}

.summary-table th {
  font-weight: 500;
  color: var(--matrix-text-secondary);
  background-color: var(--matrix-bg-secondary);
  cursor: pointer;
  position: relative;
}

.summary-table th.sorted {
  color: var(--matrix-primary);
  font-weight: 600;
}

.summary-table th.sorted::after {
  content: "";
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  height: 2px;
  background-color: var(--matrix-primary);
}

.summary-table tbody tr {
  cursor: pointer;
  transition: background-color 0.2s ease;
}

.summary-table tbody tr:hover {
  background-color: #f8fafc;
}

.summary-table tbody tr.inactive {
  opacity: 0.7;
}

.status-col {
  width: 2rem;
}

.status-indicator {
  display: block;
  width: 0.5rem;
  height: 0.5rem;
  border-radius: 50%;
  background-color: var(--matrix-neutral);
}

.status-indicator.active {
  background-color: var(--matrix-success);
}

.status-indicator.inactive {
  background-color: var(--matrix-neutral);
}

.name-col {
  width: 30%;
}

.group-col {
  width: 25%;
}

.impact-col,
.percent-col {
  width: 15%;
  text-align: right;
}

.impact-col.positive,
.percent-col.positive {
  color: var(--matrix-positive);
}

.impact-col.negative,
.percent-col.negative {
  color: var(--matrix-negative);
}

.no-items {
  padding: 2rem;
  text-align: center;
  color: var(--matrix-text-secondary);
  font-style: italic;
}

/* Detailed items view */
.detailed-items {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: 1rem;
  padding: 1rem;
}

.detailed-item {
  background-color: white;
  border-radius: 0.375rem;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  border: 1px solid var(--matrix-border);
  overflow: hidden;
  transition: all 0.2s ease;
  cursor: pointer;
}

.detailed-item:hover {
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  transform: translateY(-2px);
}

.detailed-item.active {
  border-left: 3px solid var(--matrix-success);
}

.detailed-item.inactive {
  border-left: 3px solid var(--matrix-neutral);
  opacity: 0.8;
}

.item-header {
  padding: 0.75rem;
  border-bottom: 1px solid var(--matrix-border);
  background-color: var(--matrix-bg-secondary);
}

.item-title {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  margin-bottom: 0.25rem;
}

.item-title h4 {
  margin: 0;
  font-size: 0.875rem;
  font-weight: 600;
}

.item-group {
  font-size: 0.75rem;
  color: var(--matrix-text-secondary);
}

.item-values {
  padding: 0.75rem;
}

.value-row {
  display: flex;
  justify-content: space-between;
  padding: 0.25rem 0;
  font-size: 0.8125rem;
}

.value-label {
  color: var(--matrix-text-secondary);
}

.value {
  font-weight: 500;
}

.value.positive {
  color: var(--matrix-positive);
}

.value.negative {
  color: var(--matrix-negative);
}

.value.highlight {
  color: var(--matrix-primary);
  font-weight: 600;
}

/* Chart view */
.chart-view {
  padding: 1rem;
}

.chart-container {
  background-color: white;
  border-radius: 0.375rem;
  border: 1px solid var(--matrix-border);
  padding: 1rem;
}

.chart-placeholder {
  max-width: 800px;
  margin: 0 auto;
}

.chart-placeholder h4 {
  margin: 0 0 1rem 0;
  font-size: 1rem;
  font-weight: 600;
  color: var(--matrix-text-primary);
  text-align: center;
}

.chart-bar-container {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  margin-bottom: 0.75rem;
}

.bar-label {
  width: 25%;
  font-size: 0.8125rem;
  text-align: right;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.bar-wrapper {
  width: 50%;
  height: 1.5rem;
  background-color: var(--matrix-bg-secondary);
  border-radius: 0.25rem;
  position: relative;
}

.chart-bar {
  position: absolute;
  top: 0;
  height: 100%;
  border-radius: 0.25rem;
  transition: width 0.3s ease;
}

.chart-bar.positive {
  background-color: var(--matrix-positive);
}

.chart-bar.negative {
  background-color: var(--matrix-negative);
}

.bar-value {
  width: 25%;
  font-size: 0.8125rem;
  font-weight: 500;
  padding-left: 0.5rem;
}

/* Item detail modal */
.item-detail-modal {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: white;
  border-radius: 0.5rem;
  box-shadow: 0 10px 25px rgba(0, 0, 0, 0.25);
  width: 90%;
  max-width: 500px;
  max-height: 90vh;
  overflow-y: auto;
  z-index: 50;
}

.modal-header {
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--matrix-border);
  display: flex;
  align-items: center;
  justify-content: space-between;
  position: sticky;
  top: 0;
  background-color: white;
  z-index: 1;
}

.modal-header h3 {
  margin: 0;
  font-size: 1.125rem;
  font-weight: 600;
}

.modal-header button {
  background: none;
  border: none;
  font-size: 1.5rem;
  cursor: pointer;
  color: var(--matrix-text-secondary);
}

.modal-content {
  padding: 1.25rem;
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
}

.detail-section {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.detail-section h4 {
  margin: 0 0 0.5rem 0;
  font-size: 0.875rem;
  font-weight: 600;
  color: var(--matrix-text-primary);
  border-bottom: 1px solid var(--matrix-border);
  padding-bottom: 0.375rem;
}

.detail-row {
  display: flex;
  justify-content: space-between;
  padding: 0.25rem 0;
  font-size: 0.875rem;
}

.detail-value.status-active {
  color: var(--matrix-success);
  font-weight: 500;
}

.detail-value.status-inactive {
  color: var(--matrix-neutral);
  font-weight: 500;
}

/* Animation for modal */
@keyframes modalFadeIn {
  from {
    opacity: 0;
    transform: translate(-50%, -45%);
  }
  to {
    opacity: 1;
    transform: translate(-50%, -50%);
  }
}

.item-detail-modal {
  animation: modalFadeIn 0.3s ease;
}

/* Responsive adjustments */
@media (max-width: 1024px) {
  .detailed-items {
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
  }
}

@media (max-width: 768px) {
  .summary-controls {
    flex-direction: column;
    align-items: stretch;
  }

  .simulation-control {
    margin-left: 0;
    justify-content: space-between;
  }

  .sim-slider {
    flex: 1;
  }

  .summary-table th,
  .summary-table td {
    padding: 0.5rem;
  }

  .group-col {
    display: none;
  }

  .detailed-items {
    grid-template-columns: 1fr;
  }
}

@media (max-width: 480px) {
  .summary-stats {
    flex-direction: column;
  }

  .stat-item {
    flex: 1 1 100%;
  }

  .item-detail-modal {
    width: 95%;
  }
}
```

### Value Tooltip Styles (value-tooltip.css)

```css
/* Value Tooltip Component Styles */
.tooltip-container {
  position: relative;
  display: inline-block;
}

.value-tooltip {
  position: absolute;
  background-color: white;
  border-radius: 0.375rem;
  box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2);
  border: 1px solid var(--matrix-border);
  z-index: 50;
  overflow: hidden;
  pointer-events: none;
}

.tooltip-top {
  bottom: calc(100% + 10px);
  left: 50%;
  transform: translateX(-50%);
}

.tooltip-bottom {
  top: calc(100% + 10px);
  left: 50%;
  transform: translateX(-50%);
}

.tooltip-left {
  right: calc(100% + 10px);
  top: 50%;
  transform: translateY(-50%);
}

.tooltip-right {
  left: calc(100% + 10px);
  top: 50%;
  transform: translateY(-50%);
}

.tooltip-content {
  padding: 0;
}

.tooltip-header {
  padding: 0.75rem;
  border-bottom: 1px solid var(--matrix-border);
  display: flex;
  align-items: center;
  justify-content: space-between;
  background-color: var(--matrix-bg-secondary);
}

.tooltip-header h4 {
  margin: 0;
  font-size: 0.875rem;
  font-weight: 600;
  color: var(--matrix-text-primary);
}

.status-indicator {
  display: inline-block;
  font-size: 0.6875rem;
  padding: 0.125rem 0.375rem;
  border-radius: 1rem;
}

.status-indicator.active {
  background-color: #f0fff4;
  color: var(--matrix-success);
  border: 1px solid #c6f6d5;
}

.status-indicator.inactive {
  background-color: #f7fafc;
  color: var(--matrix-neutral);
  border: 1px solid #e2e8f0;
}

.tooltip-group {
  padding: 0.5rem 0.75rem;
  font-size: 0.75rem;
  background-color: #f8fafc;
  border-bottom: 1px solid var(--matrix-border);
}

.group-label {
  color: var(--matrix-text-secondary);
  margin-right: 0.5rem;
}

.group-name {
  font-weight: 500;
}

.tooltip-details {
  padding: 0.75rem;
}

.detail-row {
  display: flex;
  justify-content: space-between;
  padding: 0.25rem 0;
  font-size: 0.75rem;
}

.detail-label {
  color: var(--matrix-text-secondary);
}

.detail-value {
  font-weight: 500;
}

.detail-value.positive {
  color: var(--matrix-positive);
}

.detail-value.negative {
  color: var(--matrix-negative);
}

.detail-value.highlight {
  color: var(--matrix-primary);
  font-weight: 600;
}

.percent-change {
  font-size: 0.6875rem;
  margin-left: 0.25rem;
  opacity: 0.8;
}

.tooltip-matrix {
  padding: 0.75rem;
  background-color: #f8fafc;
  border-top: 1px solid var(--matrix-border);
}

.tooltip-matrix h5 {
  margin: 0 0 0.5rem 0;
  font-size: 0.75rem;
  font-weight: 600;
  color: var(--matrix-text-secondary);
}

.matrix-info {
  display: flex;
  gap: 1rem;
}

.matrix-row {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-size: 0.75rem;
}

.matrix-label {
  color: var(--matrix-text-secondary);
}

.matrix-value {
  font-weight: 500;
}

/* Animation for tooltip */
@keyframes tooltipFadeIn {
  from {
    opacity: 0;
    transform: scale(0.95);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

.value-tooltip {
  animation: tooltipFadeIn 0.2s ease;
  transform-origin: center top;
}

/* Tooltip arrow */
.tooltip-top::after {
  content: "";
  position: absolute;
  bottom: -6px;
  left: 50%;
  transform: translateX(-50%) rotate(45deg);
  width: 12px;
  height: 12px;
  background-color: white;
  border-right: 1px solid var(--matrix-border);
  border-bottom: 1px solid var(--matrix-border);
}

.tooltip-bottom::after {
  content: "";
  position: absolute;
  top: -6px;
  left: 50%;
  transform: translateX(-50%) rotate(45deg);
  width: 12px;
  height: 12px;
  background-color: white;
  border-left: 1px solid var(--matrix-border);
  border-top: 1px solid var(--matrix-border);
}

.tooltip-left::after {
  content: "";
  position: absolute;
  right: -6px;
  top: 50%;
  transform: translateY(-50%) rotate(45deg);
  width: 12px;
  height: 12px;
  background-color: white;
  border-right: 1px solid var(--matrix-border);
  border-top: 1px solid var(--matrix-border);
}

.tooltip-right::after {
  content: "";
  position: absolute;
  left: -6px;
  top: 50%;
  transform: translateY(-50%) rotate(45deg);
  width: 12px;
  height: 12px;
  background-color: white;
  border-left: 1px solid var(--matrix-border);
  border-bottom: 1px solid var(--matrix-border);
}
```

### Documentation Guide Styles (documentation-guide.css)

```css
/* Matrix Integration Guide Styles */
.matrix-integration-guide {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: white;
  z-index: 100;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
}

.guide-header {
  padding: 1rem 1.5rem;
  background-color: var(--matrix-primary);
  color: white;
  display: flex;
  align-items: center;
  justify-content: space-between;
  position: sticky;
  top: 0;
  z-index: 10;
}

.guide-header h2 {
  margin: 0;
  font-size: 1.5rem;
  font-weight: 600;
}

.close-button {
  background: none;
  border: none;
  color: white;
  font-size: 1.5rem;
  cursor: pointer;
  transition: opacity 0.2s ease;
}

.close-button:hover {
  opacity: 0.8;
}

.guide-content {
  display: flex;
  flex: 1;
  height: calc(100vh - 4rem);
}

.guide-nav {
  width: 250px;
  background-color: var(--matrix-bg-secondary);
  border-right: 1px solid var(--matrix-border);
  padding: 1.5rem 1rem;
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.nav-button {
  padding: 0.75rem 1rem;
  text-align: left;
  background: none;
  border: none;
  border-radius: 0.375rem;
  font-size: 0.9375rem;
  cursor: pointer;
  transition: all 0.2s ease;
  color: var(--matrix-text-secondary);
}

.nav-button:hover {
  background-color: var(--matrix-bg-primary);
  color: var(--matrix-text-primary);
}

.nav-button.active {
  background-color: var(--matrix-primary);
  color: white;
  font-weight: 500;
}

.guide-section-content {
  flex: 1;
  padding: 2rem;
  overflow-y: auto;
}

.section {
  max-width: 800px;
  margin: 0 auto;
}

.section h3 {
  margin: 0 0 1rem 0;
  font-size: 1.5rem;
  font-weight: 600;
  color: var(--matrix-primary);
  border-bottom: 2px solid var(--matrix-border);
  padding-bottom: 0.5rem;
}

.section h4 {
  margin: 1.5rem 0 0.75rem 0;
  font-size: 1.125rem;
  font-weight: 600;
  color: var(--matrix-text-primary);
}

.section p {
  margin: 0 0 1rem 0;
  font-size: 1rem;
  line-height: 1.6;
  color: var(--matrix-text-primary);
}

.section ul,
.section ol {
  margin: 0 0 1.5rem 0;
  padding-left: 1.5rem;
}

.section li {
  margin-bottom: 0.5rem;
  font-size: 1rem;
  line-height: 1.6;
}

.section pre {
  background-color: #1a202c;
  color: #e2e8f0;
  padding: 1rem;
  border-radius: 0.375rem;
  overflow-x: auto;
  font-family: Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  font-size: 0.875rem;
  line-height: 1.5;
  margin: 1rem 0 1.5rem 0;
}

.section code {
  font-family: Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  font-size: 0.875rem;
  background-color: var(--matrix-bg-secondary);
  padding: 0.125rem 0.25rem;
  border-radius: 0.25rem;
}

.note {
  background-color: #ebf8ff;
  border-left: 4px solid #4299e1;
  padding: 1rem;
  border-radius: 0 0.375rem 0.375rem 0;
  margin: 1.5rem 0;
}

.note p {
  margin: 0;
  color: #2c5282;
}

/* Animation for section transitions */
@keyframes sectionFadeIn {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.section-content {
  animation: sectionFadeIn 0.3s ease;
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .guide-content {
    flex-direction: column;
    height: auto;
  }

  .guide-nav {
    width: 100%;
    border-right: none;
    border-bottom: 1px solid var(--matrix-border);
    padding: 1rem;
  }

  .guide-section-content {
    padding: 1.5rem;
  }
}

@media (max-width: 480px) {
  .guide-header h2 {
    font-size: 1.25rem;
  }

  .guide-section-content {
    padding: 1rem;
  }

  .section h3 {
    font-size: 1.25rem;
  }

  .section h4 {
    font-size: 1rem;
  }

  .section pre {
    font-size: 0.75rem;
  }
}
```

### Main Animation Styles (animations.css)

```css
/* Global Animation Styles */
:root {
  --animation-fast: 0.2s;
  --animation-medium: 0.3s;
  --animation-slow: 0.5s;
  --ease-standard: cubic-bezier(0.4, 0, 0.2, 1);
  --ease-in-out: cubic-bezier(0.83, 0, 0.17, 1);
  --ease-bounce: cubic-bezier(0.34, 1.56, 0.64, 1);
}

/* Basic transitions */
.fade-transition {
  transition: opacity var(--animation-medium) var(--ease-standard);
}

.scale-transition {
  transition: transform var(--animation-medium) var(--ease-standard);
}

.color-transition {
  transition: color var(--animation-fast) var(--ease-standard),
              background-color var(--animation-fast) var(--ease-standard),
              border-color var(--animation-fast) var(--ease-standard);
}

/* Component entry animations */
@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes slideDown {
  from {
    opacity: 0;
    transform: translateY(-20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes slideUp {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes slideInRight {
  from {
    opacity: 0;
    transform: translateX(20px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes slideInLeft {
  from {
    opacity: 0;
    transform: translateX(-20px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes scaleIn {
  from {
    opacity: 0;
    transform: scale(0.9);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

@keyframes bounce {
  0% {
    transform: scale(0.95);
  }
  50% {
    transform: scale(1.05);
  }
  100% {
    transform: scale(1);
  }
}

/* Apply animations to components */
.matrix-panel {
  animation: slideUp var(--animation-medium) var(--ease-bounce);
}

.detailed-item {
  animation: scaleIn var(--animation-medium) var(--ease-standard);
}

.dialog,
.modal,
.tooltip {
  animation: scaleIn var(--animation-fast) var(--ease-bounce);
}

.scaling-item {
  animation: slideInRight var(--animation-medium) var(--ease-standard);
}

.form-row-enter {
  animation: slideDown var(--animation-medium) var(--ease-standard);
}

.tab-enter {
  animation: fadeIn var(--animation-fast) var(--ease-standard);
}

/* Interactive animations */
.interactive-element {
  transition: all var(--animation-medium) var(--ease-standard);
}

.interactive-element:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

.interactive-element:active {
  transform: translateY(0);
}

.pulse-animation {
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0% {
    transform: scale(1);
    opacity: 1;
  }
  50% {
    transform: scale(1.05);
    opacity: 0.8;
  }
  100% {
    transform: scale(1);
    opacity: 1;
  }
}

/* Loading animations */
.loading-spinner {
  width: 2rem;
  height: 2rem;
  border: 3px solid rgba(0, 0, 0, 0.1);
  border-radius: 50%;
  border-top-color: var(--matrix-primary);
  animation: spin 1s linear infinite;
}

@keyframes spin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

.loading-pulse {
  display: inline-block;
  position: relative;
  width: 80px;
  height: 16px;
}

.loading-pulse div {
  position: absolute;
  top: 0;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: var(--matrix-primary);
  animation: loading-pulse 1.2s cubic-bezier(0, 0.5, 0.5, 1) infinite;
}

.loading-pulse div:nth-child(1) {
  left: 8px;
  animation-delay: -0.24s;
}

.loading-pulse div:nth-child(2) {
  left: 32px;
  animation-delay: -0.12s;
}

.loading-pulse div:nth-child(3) {
  left: 56px;
  animation-delay: 0;
}

@keyframes loading-pulse {
  0% {
    top: 8px;
    height: 16px;
  }
  50%, 100% {
    top: 12px;
    height: 8px;
  }
}

/* Framer Motion Style Enhancements */
.framer-container {
  position: relative;
  overflow: hidden;
}

.framer-content-wrap {
  display: flex;
  flex-direction: column;
  position: relative;
}

/* Page transitions */
.page-transition-enter {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  opacity: 0;
  transform: translateX(50px);
}

.page-transition-enter-active {
  opacity: 1;
  transform: translateX(0);
  transition: opacity var(--animation-slow) var(--ease-standard),
              transform var(--animation-slow) var(--ease-standard);
}

.page-transition-exit {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  opacity: 1;
  transform: translateX(0);
}

.page-transition-exit-active {
  opacity: 0;
  transform: translateX(-50px);
  transition: opacity var(--animation-slow) var(--ease-standard),
              transform var(--animation-slow) var(--ease-standard);
}

/* Staggered list item animations */
.staggered-list {
  display: flex;
  flex-direction: column;
}

.staggered-item {
  opacity: 0;
  transform: translateY(20px);
}

.staggered-item-appear {
  animation: staggeredAppear var(--animation-medium) var(--ease-bounce) forwards;
}

/* Staggered animation with dynamic delays */
.staggered-item:nth-child(1) { animation-delay: 0s; }
.staggered-item:nth-child(2) { animation-delay: 0.05s; }
.staggered-item:nth-child(3) { animation-delay: 0.1s; }
.staggered-item:nth-child(4) { animation-delay: 0.15s; }
.staggered-item:nth-child(5) { animation-delay: 0.2s; }
.staggered-item:nth-child(6) { animation-delay: 0.25s; }
.staggered-item:nth-child(7) { animation-delay: 0.3s; }
.staggered-item:nth-child(8) { animation-delay: 0.35s; }
.staggered-item:nth-child(9) { animation-delay: 0.4s; }
.staggered-item:nth-child(10) { animation-delay: 0.45s; }

@keyframes staggeredAppear {
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Hover effect animations */
.hover-lift {
  transition: transform var(--animation-fast) var(--ease-standard);
}

.hover-lift:hover {
  transform: translateY(-2px);
}

.hover-scale {
  transition: transform var(--animation-fast) var(--ease-standard);
}

.hover-scale:hover {
  transform: scale(1.05);
}

.hover-glow {
  transition: box-shadow var(--animation-fast) var(--ease-standard);
}

.hover-glow:hover {
  box-shadow: 0 0 10px rgba(66, 153, 225, 0.5);
}
``

### Responsive Styles (responsive.css)

```css
/* Responsive Design Styles */
:root {
  --breakpoint-sm: 640px;
  --breakpoint-md: 768px;
  --breakpoint-lg: 1024px;
  --breakpoint-xl: 1280px;
  --breakpoint-2xl: 1536px;
}

/* Mobile-first approach base styles */
html {
  font-size: 16px;
}

body {
  margin: 0;
  overflow-x: hidden;
}

/* Fluid typography */
@media (min-width: 640px) {
  html {
    font-size: calc(16px + 0.2vw);
  }
}

@media (min-width: 1280px) {
  html {
    font-size: calc(16px + 0.3vw);
  }
}

/* Responsive container */
.matrix-container {
  width: 100%;
  margin: 0 auto;
  padding: 0 1rem;
}

@media (min-width: 640px) {
  .matrix-container {
    padding: 0 1.5rem;
  }
}

@media (min-width: 768px) {
  .matrix-container {
    padding: 0 2rem;
  }
}

@media (min-width: 1024px) {
  .matrix-container {
    padding: 0 2.5rem;
  }
}

/* Responsive layout */
.matrix-layout {
  display: grid;
  grid-template-columns: 1fr;
  grid-template-rows: auto auto 1fr;
  grid-template-areas:
    "header"
    "sidebar"
    "content";
  height: 100vh;
  width: 100%;
}

@media (min-width: 768px) {
  .matrix-layout {
    grid-template-columns: 280px 1fr;
    grid-template-rows: auto 1fr;
    grid-template-areas:
      "header header"
      "sidebar content";
  }
}

@media (min-width: 1024px) {
  .matrix-layout {
    grid-template-columns: 320px 1fr;
  }
}

/* Responsive panels */
.matrix-panel {
  margin-bottom: 1rem;
}

@media (min-width: 768px) {
  .matrix-panel {
    margin-bottom: 1.5rem;
  }
}

/* Responsive forms */
.matrix-form {
  display: grid;
  grid-template-columns: 1fr;
  gap: 1rem;
}

@media (min-width: 640px) {
  .matrix-form {
    grid-template-columns: repeat(2, 1fr);
    gap: 1.25rem;
  }
}

@media (min-width: 1024px) {
  .matrix-form {
    grid-template-columns: repeat(3, 1fr);
    gap: 1.5rem;
  }
}

@media (min-width: 1280px) {
  .matrix-form {
    grid-template-columns: repeat(4, 1fr);
  }
}

/* Form groups */
.form-group {
  margin-bottom: 1rem;
}

.form-group label {
  display: block;
  margin-bottom: 0.375rem;
  font-size: 0.875rem;
}

@media (min-width: 768px) {
  .form-group {
    margin-bottom: 1.25rem;
  }

  .form-group label {
    font-size: 0.9375rem;
  }
}

/* Responsive tables */
.matrix-table-container {
  width: 100%;
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
}

@media (max-width: 768px) {
  .responsive-table {
    display: block;
  }

  .responsive-table thead {
    display: none;
  }

  .responsive-table tbody {
    display: block;
  }

  .responsive-table tr {
    display: block;
    margin-bottom: 1rem;
    border: 1px solid var(--matrix-border);
    border-radius: 0.375rem;
  }

  .responsive-table td {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.75rem;
    border-bottom: 1px solid var(--matrix-border);
    text-align: right;
  }

  .responsive-table td:before {
    content: attr(data-label);
    font-weight: 500;
    text-align: left;
    color: var(--matrix-text-secondary);
  }

  .responsive-table td:last-child {
    border-bottom: none;
  }
}

/* Responsive scaling items */
.enhanced-scaling-container {
  display: grid;
  grid-template-columns: 1fr;
  gap: 1rem;
}

@media (min-width: 768px) {
  .enhanced-scaling-container {
    grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
    gap: 1.25rem;
  }
}

/* Responsive actions bar */
.actions-bar {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
  margin-bottom: 1rem;
}

@media (min-width: 640px) {
  .actions-bar {
    flex-wrap: nowrap;
    gap: 0.75rem;
    margin-bottom: 1.5rem;
  }
}

/* Responsive tabs */
.matrix-tabs {
  overflow-x: auto;
  white-space: nowrap;
  -webkit-overflow-scrolling: touch;
  border-bottom: 1px solid var(--matrix-border);
}

.tab-list {
  display: inline-flex;
  padding: 0;
  margin: 0;
}

.tab-item {
  padding: 0.75rem 1rem;
  border-bottom: 2px solid transparent;
  cursor: pointer;
  transition: all 0.2s ease;
}

.tab-item.active {
  border-bottom-color: var(--matrix-primary);
  color: var(--matrix-primary);
  font-weight: 500;
}

@media (max-width: 640px) {
  .tab-item {
    padding: 0.5rem 0.75rem;
    font-size: 0.875rem;
  }
}

/* Responsive dialogs */
.matrix-dialog {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 50;
  padding: 1rem;
}

.dialog-content {
  background-color: white;
  border-radius: 0.5rem;
  box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
  width: 100%;
  max-width: 480px;
  max-height: 90vh;
  overflow-y: auto;
}

@media (max-width: 640px) {
  .dialog-content {
    max-width: 100%;
    max-height: 100vh;
    border-radius: 0;
  }

  .dialog-actions {
    flex-direction: column;
    gap: 0.5rem;
  }

  .dialog-actions button {
    width: 100%;
  }
}

/* Responsive tooltips */
@media (max-width: 640px) {
  .value-tooltip {
    position: fixed;
    top: auto !important;
    left: 0 !important;
    right: 0 !important;
    bottom: 0 !important;
    transform: none !important;
    max-width: 100% !important;
    width: 100% !important;
    border-radius: 0.75rem 0.75rem 0 0;
    animation: slideUpTooltip 0.3s ease !important;
  }

  @keyframes slideUpTooltip {
    from {
      transform: translateY(100%);
    }
    to {
      transform: translateY(0);
    }
  }

  .tooltip-top::after,
  .tooltip-bottom::after,
  .tooltip-left::after,
  .tooltip-right::after {
    display: none;
  }
}

/* Responsive Summary Panel */
@media (max-width: 768px) {
  .enhanced-summary-panel {
    margin-top: 1rem;
  }

  .summary-header h3 {
    font-size: 1rem;
  }

  .summary-controls {
    flex-direction: column;
    gap: 0.75rem;
  }

  .search-control,
  .filter-control,
  .view-control,
  .simulation-control {
    width: 100%;
  }

  .status-col {
    width: 1.5rem;
  }

  .name-col {
    width: 45%;
  }

  .group-col {
    display: none;
  }

  .impact-col,
  .percent-col {
    width: 25%;
  }

  .detailed-items {
    grid-template-columns: 1fr;
  }
}

/* Print styles */
@media print {
  .matrix-layout {
    display: block;
    height: auto;
  }

  .matrix-header,
  .matrix-sidebar,
  .actions-bar,
  button:not(.print-button) {
    display: none !important;
  }

  .matrix-content {
    padding: 0;
    overflow: visible;
  }

  .matrix-panel {
    box-shadow: none;
    border: 1px solid #e2e8f0;
    margin-bottom: 2rem;
    page-break-inside: avoid;
  }

  a {
    text-decoration: none !important;
    color: #000 !important;
  }

  * {
    -webkit-print-color-adjust: exact !important;
    color-adjust: exact !important;
  }
}
```

These CSS files provide a comprehensive styling framework for the ModEcon Matrix System, with rich visual interactions, responsive design, and smooth animations. The styles are organized in a modular way to allow easy maintenance and extension. Together, they create a cohesive and professional user interface that enhances the functionality of the matrix-based approach to financial modeling.
















































































































































































I'll provide the updated code for implementing the matrix-based form values system into your existing codebase. Based on your requirements, I'll focus on ensuring the code is complete, preserves naming integrity, and handles multi-part changes appropriately.

# MatrixSubmissionService.js

```javascript
/**
 * Matrix Submission Service - Handles matrix-based form value submissions to backend services
 */
class MatrixSubmissionService {
  constructor() {
    this.submitParameterUrl = 'http://localhost:3040/append/';
    this.submitCompleteSetUrl = 'http://localhost:3052/append/';
    this.formatterUrl = 'http://localhost:3050/formatter/';
    this.module1Url = 'http://localhost:3051/module1/';
    this.configModulesUrl = 'http://localhost:3053/config_modules/';
    this.tableUrl = 'http://localhost:3054/table/';
  }

  /**
   * Submit the matrix-based form values to the server
   * @param {Object} matrixFormValues The matrix form values object
   * @param {string} versionId The version ID
   * @returns {Promise<Object>} The response from the server
   */
  async submitMatrixFormValues(matrixFormValues, versionId) {
    try {
      // Prepare filtered values format with matrix data
      const filteredValues = this.prepareFilteredValues(matrixFormValues, versionId);

      // Submit the filtered values
      const submitResponse = await this.submitFilteredValues(filteredValues, versionId);

      // Run the formatter to process the submitted values
      const formatterResponse = await this.runFormatter(versionId);

      // Run module1 to build the configuration matrix
      const module1Response = await this.runModule1(versionId);

      // Run config_modules to create configuration modules
      const configModulesResponse = await this.runConfigModules(versionId);

      // Run table module to create the variable table
      const tableResponse = await this.runTable(versionId);

      return {
        submit: submitResponse,
        formatter: formatterResponse,
        module1: module1Response,
        configModules: configModulesResponse,
        table: tableResponse
      };
    } catch (error) {
      console.error('Error submitting matrix form values:', error);
      throw error;
    }
  }

  /**
   * Prepare filtered values from matrix form values
   * @param {Object} matrixFormValues The matrix form values
   * @param {string} versionId The version ID (e.g., 'v1', 'v2')
   * @returns {string} The filtered values JSON string
   */
  prepareFilteredValues(matrixFormValues, versionId) {
    const filteredValues = { filteredValues: [] };
    const activeVersion = versionId || matrixFormValues.versions.active;
    const activeZone = matrixFormValues.zones.active;

    // Extract the numeric version from the versionId (e.g., 'v1' -> '1')
    const numericVersion = activeVersion.replace(/\D/g, '');

    // Process each parameter in the matrix
    Object.keys(matrixFormValues.formMatrix).forEach(paramId => {
      const param = matrixFormValues.formMatrix[paramId];

      // Skip parameters that don't have matrix values for the active version/zone
      if (!param.matrix[activeVersion] || !param.matrix[activeVersion][activeZone]) {
        return;
      }

      // Get the parameter value for the active version and zone
      const value = param.matrix[activeVersion][activeZone];

      // Add the parameter to the filtered values array
      filteredValues.filteredValues.push({
        id: paramId,
        value: value,
        start: param.efficacyPeriod.start.value,
        end: param.efficacyPeriod.end.value,
        remarks: param.remarks || ""
      });

      // Special handling for vector values (Amount4, Amount5, Amount6, Amount7)
      // For vector quantities (vAmountX) and prices (rAmountY)
      if (param.dynamicAppendix && param.dynamicAppendix.itemState) {
        const itemState = param.dynamicAppendix.itemState;

        // Only include items that are turned on (status = 'on')
        if (itemState.status === 'on') {
          // Handle vKey vector items
          if (itemState.vKey && paramId.includes('vAmount')) {
            const vIndex = parseInt(paramId.replace('vAmount', ''));
            filteredValues.filteredValues.push({
              id: `variableCostsAmount4_${vIndex - 39}`,
              value: value,
              start: param.efficacyPeriod.start.value,
              end: param.efficacyPeriod.end.value,
              remarks: `Vector Quantity Item ${vIndex - 39}`
            });
          }

          // Handle rKey vector items
          if (itemState.rKey && paramId.includes('rAmount')) {
            const rIndex = parseInt(paramId.replace('rAmount', ''));
            filteredValues.filteredValues.push({
              id: `amounts_per_unitAmount5_${rIndex - 59}`,
              value: value,
              start: param.efficacyPeriod.start.value,
              end: param.efficacyPeriod.end.value,
              remarks: `Vector Price Item ${rIndex - 59}`
            });
          }
        }
      }
    });

    return JSON.stringify(filteredValues, null, 2);
  }

  /**
   * Submit filtered values to the server
   * @param {string} filteredValues The filtered values JSON string
   * @param {string} version The version ID
   * @returns {Promise<Object>} The response from the server
   */
  async submitFilteredValues(filteredValues, version) {
    try {
      // Extract numeric version from version ID (e.g., 'v1' -> '1')
      const numericVersion = version.replace(/\D/g, '');

      // Submit to the complete set endpoint
      const response = await fetch(this.submitCompleteSetUrl + numericVersion, {
        method: 'POST',
        headers: {
          'Content-Type': 'text/plain'
        },
        body: filteredValues
      });

      if (!response.ok) {
        throw new Error(`Failed to submit filtered values: ${response.statusText}`);
      }

      return await response.text();
    } catch (error) {
      console.error('Error submitting filtered values:', error);
      throw error;
    }
  }

  /**
   * Run the formatter module
   * @param {string} version The version ID
   * @returns {Promise<Object>} The response from the server
   */
  async runFormatter(version) {
    try {
      // Extract numeric version from version ID
      const numericVersion = version.replace(/\D/g, '');

      const response = await fetch(this.formatterUrl + numericVersion, {
        method: 'GET'
      });

      if (!response.ok) {
        throw new Error(`Failed to run formatter: ${response.statusText}`);
      }

      return await response.json();
    } catch (error) {
      console.error('Error running formatter:', error);
      throw error;
    }
  }

  /**
   * Run module1 to build the configuration matrix
   * @param {string} version The version ID
   * @returns {Promise<Object>} The response from the server
   */
  async runModule1(version) {
    try {
      // Extract numeric version from version ID
      const numericVersion = version.replace(/\D/g, '');

      const response = await fetch(this.module1Url + numericVersion, {
        method: 'GET'
      });

      if (!response.ok) {
        throw new Error(`Failed to run module1: ${response.statusText}`);
      }

      return await response.json();
    } catch (error) {
      console.error('Error running module1:', error);
      throw error;
    }
  }

  /**
   * Run config_modules to create configuration modules
   * @param {string} version The version ID
   * @returns {Promise<Object>} The response from the server
   */
  async runConfigModules(version) {
    try {
      // Extract numeric version from version ID
      const numericVersion = version.replace(/\D/g, '');

      const response = await fetch(this.configModulesUrl + numericVersion, {
        method: 'GET'
      });

      if (!response.ok) {
        throw new Error(`Failed to run config_modules: ${response.statusText}`);
      }

      return await response.json();
    } catch (error) {
      console.error('Error running config_modules:', error);
      throw error;
    }
  }

  /**
   * Run table module to create the variable table
   * @param {string} version The version ID
   * @returns {Promise<Object>} The response from the server
   */
  async runTable(version) {
    try {
      // Extract numeric version from version ID
      const numericVersion = version.replace(/\D/g, '');

      const response = await fetch(this.tableUrl + numericVersion, {
        method: 'GET'
      });

      if (!response.ok) {
        throw new Error(`Failed to run table module: ${response.statusText}`);
      }

      return await response.json();
    } catch (error) {
      console.error('Error running table module:', error);
      throw error;
    }
  }
}

export default MatrixSubmissionService;
```

# HomePage.js (Updated for Matrix-Based Form Values)

I'll now update the HomePage.js file to work with the new matrix-based form values structure. Since this file is quite large, I'll focus on the key changes required to integrate the matrix-based form values.

```javascript
import { useEffect, useState } from 'react';
import { Tab, TabList, TabPanel, Tabs } from 'react-tabs';
import 'react-tabs/style/react-tabs.css';
import CustomizableImage from './components/modules/CustomizableImage';
import CustomizableTable from './components/modules/CustomizableTable';
import ExtendedScaling from 'src/components/truly_extended_scaling/ExtendedScaling';
import FactEngine from './components/modules/FactEngine';
import FactEngineAdmin from './components/modules/FactEngineAdmin';
import GeneralFormConfig from './GeneralFormConfig.js';
import './styles/HomePage.CSS/HomePage1.css';
import './styles/HomePage.CSS/HomePage2.css';
import './styles/HomePage.CSS/HomePage3.css';
import './styles/HomePage.CSS/HomePage5.css';
import './styles/HomePage.CSS/HomePage6.css';
import './styles/HomePage.CSS/CustomizableTable.css';
import './styles/HomePage.CSS/HomePage_AboutUs.css';
import './styles/HomePage.CSS/HomePage_buttons.css';
import './styles/HomePage.CSS/HomePage_monitoring.css';
import './styles/HomePage.CSS/HomePage_FactEngine.css';
import './styles/HomePage.CSS/HomePage_FactAdmin.css';
import './styles/HomePage.CSS/HomePage_neumorphic-tabs.css';
import './styles/Themes/dark-theme.css';
import './styles/Themes/light-theme.css';
import './styles/Themes/creative-theme.css';
import PropertySelector from './PropertySelector.js';
import VersionSelector from './VersionSelector.js';
import SpatialTransformComponent from './Naturalmotion.js'
// Import the new matrix-based form values hook
import useMatrixFormValues from './useMatrixFormValues.js';
import './styles/HomePage.CSS/ResetOptionsPopup.css';
import './styles/HomePage.CSS/RunOptionsPopup.css';
import versionEventEmitter from './state/EventEmitter';
import TestingZone from './components/modules/TestingZone';
import CalculationMonitor from './components/modules/CalculationMonitor';
import SensitivityMonitor from './components/modules/SensitivityMonitor';
import ConfigurationMonitor from './components/modules/ConfigurationMonitor';
import ThemeButton from './components/modules/ThemeButton';
import PlotsTabs from './components/modules/PlotsTabs';
import SensitivityPlotsTabs from './components/modules/SensitivityPlotsTabs';
import CentralScalingTab from 'src/components/truly_extended_scaling/CentralScalingTab';
import StickerHeader from './components/modules/HeaderBackground';
import ProcessEconomicsLibrary from './components/process_economics_pilot/integration-module';
// Import the new MatrixSubmissionService
import MatrixSubmissionService from './MatrixSubmissionService';

const HomePageContent = () => {
    const [selectedVersions, setSelectedVersions] = useState([1]);
    const [activeTab, setActiveTab] = useState('Input');
    useEffect(() => {
        const handleVersionChange = (version) => {
            setSelectedVersions(Array.isArray(version) ? version : [version]);
        };

        versionEventEmitter.on('versionChange', handleVersionChange);
        return () => {
            versionEventEmitter.off('versionChange', handleVersionChange);
        };
    }, []);
    const [activeSubTab, setActiveSubTab] = useState('ProjectConfig');
    const [selectedProperties, setSelectedProperties] = useState([]);
    const [season, setSeason] = useState('dark');
    const [loadingStates, setLoadingStates] = useState({
        html: false,
        csv: false,
        plots: false,
    });
    const [contentLoaded, setContentLoaded] = useState({});
    const [iframesLoaded, setIframesLoaded] = useState({});
    const [imagesLoaded, setImagesLoaded] = useState({});
    const [contentLoadingState, setContentLoadingState] = useState({
        csv: false,
        html: false,
        plots: false,
        iframes: {},
        images: {},
        content: {},
    });

    useEffect(() => {
        setContentLoadingState((prev) => ({
            ...prev,
            csv: activeTab === 'Case1',
            html: activeTab === 'Case2',
            plots: activeTab === 'Case3',
            iframes: {},
            images: {},
            content: {},
        }));
    }, [activeTab]);

    useEffect(() => {
        if (contentLoadingState.csv || contentLoadingState.html || contentLoadingState.plots) {
            const timer = setTimeout(() => {
                setContentLoadingState((prev) => ({
                    ...prev,
                    content: { ...prev.content, [activeTab]: true },
                }));
            }, 100);
            return () => clearTimeout(timer);
        }
    }, [contentLoadingState.csv, contentLoadingState.html, contentLoadingState.plots, activeTab]);

    useEffect(() => {
        // Remove all theme classes
        document.documentElement.classList.remove('dark-theme', 'light-theme', 'creative-theme');

        // Map season to theme class
        const themeMap = {
            'dark': 'dark-theme',
            'light': 'light-theme',
            'creative': 'creative-theme'
        };

        // Add the appropriate theme class
        document.documentElement.classList.add(themeMap[season]);

        // Set data-theme attribute for backward compatibility
        document.documentElement.setAttribute('data-theme', season);


    }, [season]);

    // Replace useFormValues with useMatrixFormValues
    const {
        formMatrix, // Replaces formValues with formMatrix
        versions, // New state for version management
        zones, // New state for zone management
        getParameterValue, // New method to get parameter values
        updateParameterValue, // New method to update parameter values
        handleInputChange,
        handleReset,
        S,
        setS,
        F,
        setF,
        toggleF,
        V,
        setV,
        toggleV,
        subDynamicPlots,
        setSubDynamicPlots,
        toggleSubDynamicPlot,
        R,
        setR,
        toggleR,
        RF,
        setRF,
        toggleRF,
        scalingGroups,
        setScalingGroups,
        scalingBaseCosts,
        setScalingBaseCosts,
        finalResults,
        setFinalResults,
        handleFinalResultsGenerated,
        showResetOptions,
        resetOptions,
        setResetOptions,
        handleResetOptionChange,
        handleResetConfirm,
        handleResetCancel,
        showDynamicPlotsOptions,
        handleDynamicPlots,
        handleDynamicPlotsOptionChange,
        handleDynamicPlotsConfirm,
        handleDynamicPlotsCancel,
        showRunOptions,
        runOptions,
        setRunOptions,
        handleRun: handleRunOptions,
        handleRunOptionChange,
        handleRunConfirm,
        handleRunCancel,
        // New matrix-specific methods
        getEffectiveValue,
        isParameterActive,
        createVersion,
        setActiveVersion,
        createZone,
        setActiveZone,
        updateEfficacyPeriod,
        syncWithBackend,
        loadFromBackend,
        isSyncing,
        exportMatrixState,
        importMatrixState,
        propertyMapping,
        iconMapping
    } = useMatrixFormValues();

    // Initialize the MatrixSubmissionService
    const submissionService = new MatrixSubmissionService();

    const [version, setVersion] = useState('1');
    const [batchRunning, setBatchRunning] = useState(false);
    const [analysisRunning, setAnalysisRunning] = useState(false);
    const [runMode, setRunMode] = useState('cfa'); // 'cfa' or 'sensitivity'

    const renderVersionControl = () => (
        <div className="version-control-container" style={{
            position: 'sticky',
            top: '0',
            zIndex: '100',
            backgroundColor: 'var(--background-color)',
            padding: '10px',
            borderBottom: '1px solid var(--border-color)',
            marginBottom: '20px'
        }}>
            <div className="version-input-container" style={{
                display: 'flex',
                gap: '10px',
                alignItems: 'center',
                justifyContent: 'flex-end',
                maxWidth: '1200px',
                margin: '0 auto',
                padding: '0 20px'
            }}>
                <input
                    id="versionNumber"
                    type="number"
                    className="version-input"
                    placeholder="1"
                    value={version}
                    onChange={handleVersionChange}
                    style={{
                        width: '80px',
                        padding: '5px',
                        border: '1px solid var(--border-color)',
                        borderRadius: '4px'
                    }}
                />
                <button
                    className="refresh-button"
                    onClick={handleRefresh}
                    title="Refresh visualization"
                    style={{
                        padding: '5px 10px',
                        border: '1px solid var(--border-color)',
                        borderRadius: '4px',
                        background: 'var(--button-background)',
                        cursor: 'pointer'
                    }}
                >
                    
                </button>
            </div>
        </div>
    );
    const [monitoringActive, setMonitoringActive] = useState(false);
    const [isMonitoringSensitivity, setIsMonitoringSensitivity] = useState(false);
    const [csvFiles, setCsvFiles] = useState([]);
    const [subTab, setSubTab] = useState('');
    const [albumImages, setAlbumImages] = useState({});
    const [selectedAlbum, setSelectedAlbum] = useState('');
    const [albumHtmls, setAlbumHtmls] = useState({});
    const [selectedHtml, setSelectedHtml] = useState('');
    const [remarks, setRemarks] = useState('off');
    const [customizedFeatures, setcustomizedFeatures] = useState('off');
    const [selectedCalculationOption, setSelectedCalculationOption] = useState('calculateForPrice');
    const [target_row, settarget_row] = useState('20');
    const [calculatedPrices, setCalculatedPrices] = useState({});
    const [baseCosts, setBaseCosts] = useState([]);
    const [collapsedTabs, setCollapsedTabs] = useState({});
    const [isToggleSectionOpen, setIsToggleSectionOpen] = useState(false);
    const [showPopup, setShowPopup] = useState(false);
    const [popupPosition, setPopupPosition] = useState({ top: 0, left: 0 });

    // Update this effect to work with the matrix-based form values
    useEffect(() => {
        // Create a mapping of all four Amount categories
        const amountCategories = ['Amount4', 'Amount5', 'Amount6', 'Amount7'];

        // Generate scalingBaseCosts with the same structure for all categories
        const updatedScalingBaseCosts = amountCategories.reduce((result, category) => {
            // Extract entries for this category - correctly match without underscore
            const categoryEntries = Object.entries(formMatrix)
                .filter(([key]) => key.includes(category));

            // Sort entries based on their numeric suffix
            categoryEntries.sort(([keyA], [keyB]) => {
                // Extract the numeric part after the category (e.g., "Amount40" -> "40")
                const suffixA = keyA.replace(category, '');
                const suffixB = keyB.replace(category, '');
                return parseInt(suffixA) - parseInt(suffixB);
            });

            // Map sorted entries to scaling items
            result[category] = categoryEntries.map(([key, value]) => {
                const activeVersion = versions.active;
                const activeZone = zones.active;
                const paramValue = value.matrix[activeVersion]?.[activeZone] || 0;

                return {
                    id: key,
                    label: value.label || `Unnamed ${category}`,
                    value: parseFloat(paramValue) || 0,
                    baseValue: parseFloat(paramValue) || 0,
                    vKey: value.dynamicAppendix?.itemState?.vKey || null,
                    rKey: value.dynamicAppendix?.itemState?.rKey || null
                };
            });

            return result;
        }, {});

        // Update state
        setScalingBaseCosts(updatedScalingBaseCosts);
    }, [formMatrix, versions.active, zones.active]);

    const [activeScalingGroups, setActiveScalingGroups] = useState({
        Amount4: 0,
        Amount5: 0,
        Amount6: 0,
        Amount7: 0
    });

    const handleActiveGroupChange = (groupIndex, filterKeyword) => {
        setActiveScalingGroups(prev => ({
            ...prev,
            [filterKeyword]: groupIndex
        }));
    };

    const handleScaledValuesChange = (scaledValues) => {
        console.log('Scaled values:', scaledValues);
    };

    const handleScalingGroupsChange = (newGroups) => {
        setScalingGroups(newGroups);
    };

    const toggleTabCollapse = (tabId) => {
        setCollapsedTabs((prev) => ({
            ...prev,
            [tabId]: !prev[tabId],
        }));
    };

    // Update this method to work with matrix-based form values
    const loadConfiguration = async (version) => {
        try {
            const response = await fetch('http://localhost:5000/load_configuration', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ version }),
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();
            const { filteredValues } = data;

            // Process filtered values to update the matrix
            filteredValues.forEach((item) => {
                let { id, value, start, end, remarks } = item;

                // Clean up value if it's a string
                if (typeof value === 'string') {
                    value = value.trim().replace(/^"|"$/g, '');
                    value = isNaN(value) ? value : parseFloat(value);
                }

                // Update parameter value in matrix
                updateParameterValue(id, value);

                // Update efficacy period if provided
                if (start !== undefined && end !== undefined) {
                    updateEfficacyPeriod(id, parseInt(start), parseInt(end));
                }

                // Update remarks if provided
                if (remarks !== undefined) {
                    handleInputChange({ target: { value: remarks } }, id, 'remarks');
                }
            });

            console.log('Updated form matrix with loaded configuration');
        } catch (error) {
            console.error('Error loading configuration:', error);
        }
    };

    const handleOptionChange = (event) => {
        setSelectedCalculationOption(event.target.value);
    };

    const handleTargetRowChange = (event) => {
        settarget_row(event.target.value);
    };

    const toggleRemarks = () => {
        setRemarks((prevState) => (prevState === 'off' ? 'on' : 'off'));
    };

    const toggleCustomizedFeatures = () => {
        setcustomizedFeatures((prevState) => (prevState === 'off' ? 'on' : 'off'));
    };

    const [isRefreshing, setIsRefreshing] = useState(false);

    const handleRefresh = () => {
        // Store the current version
        const currentVersion = version;

        // Set refreshing state to true
        setIsRefreshing(true);

        // Force a re-fetch by setting a different version temporarily
        // Using '0' instead of empty string to ensure it's a valid version number
        // Update selectedVersions first as it's what user selects in version selector
        setSelectedVersions(['0']);
        // Then update version as a simple state
        setVersion('0');

        // Set it back to the current version after a short delay
        setTimeout(() => {
            setVersion(currentVersion);
            setIsRefreshing(false);
        }, 100);
    };

    const updatePrice = (version, price) => {
        setCalculatedPrices((prevPrices) => ({
            ...prevPrices,
            [version]: price,
        }));
    };

    const ResetOptionsPopup = ({
        show,
        options,
        onOptionChange,
        onConfirm,
        onCancel
    }) => {
        if (!show) return null;

        return (
            <div className="reset-options-popup-overlay">
                <div className="reset-options-popup">
                    <h3>Select states to reset</h3>
                    <div className="checkbox-row">
                        <label className="reset-option-label">
                            <input
                                type="checkbox"
                                checked={options.S}
                                onChange={() => onOptionChange('S')}
                            />
                            S (Sensitivity Analysis)
                        </label>
                    </div>
                    <div className="checkbox-row">
                        <label className="reset-option-label">
                            <input
                                type="checkbox"
                                checked={options.F}
                                onChange={() => onOptionChange('F')}
                            />
                            F (Factor Parameters)
                        </label>
                    </div>
                    <div className="checkbox-row">
                        <label className="reset-option-label">
                            <input
                                type="checkbox"
                                checked={options.V}
                                onChange={() => onOptionChange('V')}
                            />
                            V (Process Quantities)
                        </label>
                    </div>
                    <div className="checkbox-row">
                        <label className="reset-option-label">
                            <input
                                type="checkbox"
                                checked={options.R}
                                onChange={() => onOptionChange('R')}
                            />
                            R (Revenue Variables)
                        </label>
                    </div>
                    <div className="reset-options-buttons">
                        <button onClick={onConfirm} className="reset-confirm-button">Reset</button>
                        <button onClick={onCancel} className="reset-cancel-button">Cancel</button>
                    </div>
                </div>
            </div>
        );
    };

    const handleRunCFA = () => {
        setRunMode('cfa');
        handleRunOptions();
    };

    const handleRunSensitivity = () => {
        setRunMode('sensitivity');
        handleRunOptions();
    };

    const customHandleRunConfirm = () => {
        // First close the popup
        handleRunConfirm();
        // Then call the appropriate run function based on runMode
        if (runMode === 'cfa') {
            handleRun();
        } else if (runMode === 'sensitivity') {
            handleRuns();
        }
    };

    const DynamicPlotsOptionsPopup = ({
        show,
        options,
        onOptionChange,
        onConfirm,
        onCancel
    }) => {
        if (!show) return null;

        return (
            <div className="dynamic-plots-options-popup-overlay">
                <div className="dynamic-plots-options-popup">
                    <h3>Select Dynamic Plots to Generate</h3>
                    <div className="checkbox-row">
                        <label className="dynamic-plots-option-label">
                            <input
                                type="checkbox"
                                checked={options.SP1 === 'on'}
                                onChange={() => onOptionChange('SP1')}
                            />
                            Annual Cash Flows
                        </label>
                    </div>
                    <div className="checkbox-row">
                        <label className="dynamic-plots-option-label">
                            <input
                                type="checkbox"
                                checked={options.SP2 === 'on'}
                                onChange={() => onOptionChange('SP2')}
                            />
                            Annual Revenues
                        </label>
                    </div>
                    <div className="checkbox-row">
                        <label className="dynamic-plots-option-label">
                            <input
                                type="checkbox"
                                checked={options.SP3 === 'on'}
                                onChange={() => onOptionChange('SP3')}
                            />
                            Annual Operating Expenses
                        </label>
                    </div>
                    <div className="checkbox-row">
                        <label className="dynamic-plots-option-label">
                            <input
                                type="checkbox"
                                checked={options.SP4 === 'on'}
                                onChange={() => onOptionChange('SP4')}
                            />
                            Loan Repayment Terms
                        </label>
                    </div>
                    <div className="checkbox-row">
                        <label className="dynamic-plots-option-label">
                            <input
                                type="checkbox"
                                checked={options.SP5 === 'on'}
                                onChange={() => onOptionChange('SP5')}
                            />
                            Depreciation Schedules
                        </label>
                    </div>
                    <div className="checkbox-row">
                        <label className="dynamic-plots-option-label">
                            <input
                                type="checkbox"
                                checked={options.SP6 === 'on'}
                                onChange={() => onOptionChange('SP6')}
                            />
                            State Taxes
                        </label>
                    </div>
                    <div className="checkbox-row">
                        <label className="dynamic-plots-option-label">
                            <input
                                type="checkbox"
                                checked={options.SP7 === 'on'}
                                onChange={() => onOptionChange('SP7')}
                            />
                            Federal Taxes
                        </label>
                    </div>
                    <div className="checkbox-row">
                        <label className="dynamic-plots-option-label">
                            <input
                                type="checkbox"
                                checked={options.SP8 === 'on'}
                                onChange={() => onOptionChange('SP8')}
                            />
                            Cumulative Cash Flows
                        </label>
                    </div>
                    <div className="dynamic-plots-options-buttons">
                        <button onClick={onConfirm} className="dynamic-plots-confirm-button">Generate</button>
                        <button onClick={onCancel} className="dynamic-plots-cancel-button">Cancel</button>
                    </div>
                </div>
            </div>
        );
    };

    const RunOptionsPopup = ({
        show,
        options,
        onOptionChange,
        onConfirm,
        onCancel,
        customConfirmHandler = customHandleRunConfirm
    }) => {
        if (!show) return null;

        return (
            <div className="run-options-popup-overlay">
                <div className="run-options-popup">
                    <h3>Run CFA Options</h3>
                    <div className="checkbox-row">
                        <label className="run-option-label">
                            <input
                                type="checkbox"
                                checked={options.useSummaryItems}
                                onChange={() => onOptionChange('useSummaryItems')}
                            />
                            Use Summary Items (final results)
                        </label>
                    </div>
                    <div className="checkbox-row">
                        <label className="run-option-label">
                            <input
                                type="checkbox"
                                checked={options.includeRemarks}
                                onChange={() => onOptionChange('includeRemarks')}
                            />
                            Include Remarks
                        </label>
                    </div>
                    <div className="checkbox-row">
                        <label className="run-option-label">
                            <input
                                type="checkbox"
                                checked={options.includeCustomFeatures}
                                onChange={() => onOptionChange('includeCustomFeatures')}
                            />
                            Include Custom Features
                        </label>
                    </div>
                    <div className="run-options-buttons">
                        <button onClick={customConfirmHandler} className="run-confirm-button">Run</button>
                        <button onClick={onCancel} className="run-cancel-button">Cancel</button>
                    </div>
                </div>
            </div>
        );
    };

    const handleThemeChange = (newSeason) => {
        const themeRibbon = document.querySelector('.theme-ribbon');

        // Update theme state
        setSeason(newSeason);
        document.body.className = newSeason;
    };

    const createNewBatch = async () => {
        setBatchRunning(true);
        try {
            const response = await fetch('http://127.0.0.1:8001/create_new_batch', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
            });

            const result = await response.json();
            if (response.ok) {
                console.log(result.message);
                console.log('New Batch Number:', result.NewBatchNumber);
                setVersion(result.NewBatchNumber); // Update the version state with the new batch number
            } else {
                console.error(result.error);
            }
        } catch (error) {
            console.error('Batch creation failed', error);
        } finally {
            setBatchRunning(false);
        }
    };

    const RemoveBatch = async () => {
        try {
            const response = await fetch('http://127.0.0.1:7001/Remove_batch', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    version,
                    path: "C:/Users/Mohse/IdeaProjects2/codebase/backend/Logs/SENSITIVITY.log"
                }),
            });
            const result = await response.json();
            if (response.ok) {
                setVersion(result.max_version); // Update the version state with the max batch number
            } else {
                console.error('Batch removal failed');
            }
        } catch (error) {
            console.error('Error during batch removal:', error);
        }
    };

    const checkAndCreateUploads = async () => {
        setAnalysisRunning(true);
        try {
            const response = await fetch('http://127.0.0.1:8007/check_and_create_uploads', {
                method: 'POST',
            });
            const result = await response.json();
            if (response.ok) {
                console.log(result.message);
            } else {
                console.error(result.error);
            }
        } catch (error) {
            console.error('Analysis failed', error);
        } finally {
            setAnalysisRunning(false);
        }
    };

    // Update this method to work with matrix-based form values
    const handleRun = async () => {
        // Set loading state and reset previous results
        setAnalysisRunning(true);
        setCalculatedPrices({});

        try {
            // Create a modified formMatrix object that includes summary items for Amount4, 5, 6, and 7
            // Only if the useSummaryItems option is enabled
            const modifiedFormMatrix = { ...formMatrix };
            const activeVersion = versions.active;
            const activeZone = zones.active;

            // Replace formMatrix with summary items for tabs with keywords Amount4, 5, 6, and 7
            // Only if the useSummaryItems option is enabled
            if (runOptions.useSummaryItems) {
                ['Amount4', 'Amount5', 'Amount6', 'Amount7'].forEach(keyword => {
                    if (finalResults[keyword] && finalResults[keyword].length > 0) {
                        // For each item in the summary, update the corresponding formMatrix
                        finalResults[keyword].forEach(summaryItem => {
                            if (modifiedFormMatrix[summaryItem.id]) {
                                // Use the finalResult value from the summary item
                                const summaryValue = summaryItem.finalResult;

                                // Create a deep copy of the parameter
                                const updatedParam = JSON.parse(JSON.stringify(modifiedFormMatrix[summaryItem.id]));

                                // Update the value in the matrix for the active version and zone
                                if (!updatedParam.matrix[activeVersion]) {
                                    updatedParam.matrix[activeVersion] = {};
                                }
                                updatedParam.matrix[activeVersion][activeZone] = summaryValue;

                                // Update the parameter in the modified form matrix
                                modifiedFormMatrix[summaryItem.id] = updatedParam;
                            }
                        });
                    }
                });
            }

            // Prepare request payload with all necessary parameters
            const requestPayload = {
                selectedVersions,
                selectedV: V,
                selectedF: F,
                selectedR: R,
                selectedRF: RF,
                selectedCalculationOption,
                targetRow: target_row,
                SenParameters: S,
                formMatrix: modifiedFormMatrix, // Include modified form matrix with summary items
                versions, // Include version information
                zones, // Include zone information
                activeVersion,
                activeZone,
                summaryItems: runOptions.useSummaryItems ? {
                    Amount4: finalResults.Amount4 || [],
                    Amount5: finalResults.Amount5 || [],
                    Amount6: finalResults.Amount6 || [],
                    Amount7: finalResults.Amount7 || []
                } : {},
                includeRemarks: runOptions.includeRemarks,
                includeCustomFeatures: runOptions.includeCustomFeatures
            };

            console.log('Running CFA with parameters:', requestPayload);

            // Make API request to run calculations
            const response = await fetch('http://127.0.0.1:5007/run', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(requestPayload),
            });

            // Process the response
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || 'Failed to run calculation');
            }

            const result = await response.json();
            console.log('Calculation completed successfully:', result);

            // Check if year columns configuration was returned
            if (result.yearColumns) {
                console.log('Year columns configuration:', result.yearColumns);
                // You could store this in state if needed for other components
            }

            // If price calculation was selected, fetch the calculated prices
            if (selectedCalculationOption === 'calculateForPrice') {
                await fetchCalculatedPrices();
            }

            // Start real-time monitoring if calculation was successful
            if (result.status === 'success') {
                startRealTimeMonitoring(false); // Regular calculation (handleRun)
            }
        } catch (error) {
            console.error('Error during CFA calculation:', error);
            // Could add user notification here
        } finally {
            setAnalysisRunning(false);
        }
    };

    const fetchCalculatedPrices = async () => {
        try {
            // For each selected version, fetch the calculated price
            for (const version of selectedVersions) {
                const priceResponse = await fetch(`http://127.0.0.1:5007/price/${version}`);

                if (priceResponse.ok) {
                    const priceData = await priceResponse.json();
                    updatePrice(version, priceData.price);
                    console.log(`Fetched price for version ${version}:`, priceData.price);
                }
            }
        } catch (error) {
            console.error('Error fetching calculated prices:', error);
        }
    };

    const startRealTimeMonitoring = (isSensitivity = false) => {
        // Close any existing stream connections
        if (window.calculationEventSource) {
            window.calculationEventSource.close();
        }

        // Set monitoring active and track if it's a sensitivity analysis
        setMonitoringActive(true);
        setIsMonitoringSensitivity(isSensitivity);

        // For each selected version, set up a stream connection
        selectedVersions.forEach(version => {
            // Create a new EventSource connection for streaming updates
            const eventSource = new EventSource(`http://127.0.0.1:5007/stream_price/${version}`);
            window.calculationEventSource = eventSource;

            // Handle incoming messages
            eventSource.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    console.log(`Real-time update for version ${version}:`, data);

                    // Update price if available
                    if (data.price) {
                        updatePrice(version, data.price);
                    }

                    // Close the stream if the backend signals completion
                    if (data.complete) {
                        console.log(`Completed streaming for version ${version}`);
                        eventSource.close();
                    }
                } catch (error) {
                    console.error('Error processing stream data:', error);
                }
            };

            // Handle errors
            eventSource.onerror = (error) => {
                console.error(`Error in calculation stream for version ${version}:`, error);
                eventSource.close();
            };
        });
    };

    // Updated method to handle submission of matrix-based form values
    const handleSubmitCompleteSet = async () => {
        try {
            // Set loading state
            setAnalysisRunning(true);

            // Get the active version from matrix state
            const activeVersion = versions.active;
            const numericVersion = activeVersion.replace(/\D/g, '');

            // Use MatrixSubmissionService to submit form values
            const submissionResult = await submissionService.submitMatrixFormValues(
                {
                    formMatrix,
                    versions,
                    zones
                },
                numericVersion
            );

            console.log('Submission result:', submissionResult);
        } catch (error) {
            console.error('Error during form submission:', error);
        } finally {
            // Clear loading state
            setAnalysisRunning(false);
        }
    };

    // The rest of your code remains largely the same, with the exception
    // of passing formMatrix instead of formValues to components

    // ... rest of the implementation

    const renderForm = () => (
        <div className="form-container">
            <div className="sub-tab-buttons">
                <button
                    className={`sub-tab-button ${activeSubTab === 'ProjectConfig' ? 'active' : ''}`}
                    onClick={() => setActiveSubTab('ProjectConfig')}
                >
                    Project Configuration
                </button>
                <button
                    className={`sub-tab-button ${activeSubTab === 'LoanConfig' ? 'active' : ''}`}
                    onClick={() => setActiveSubTab('LoanConfig')}
                >
                    Loan Configuration
                </button>
                <button
                    className={`sub-tab-button ${activeSubTab === 'RatesConfig' ? 'active' : ''}`}
                    onClick={() => setActiveSubTab('RatesConfig')}
                >
                    Rates & Fixed Costs
                </button>
                <button
                    className={`sub-tab-button ${activeSubTab === 'Process1Config' ? 'active' : ''}`}
                    onClick={() => setActiveSubTab('Process1Config')}
                >
                    Process Quantities (Vs, units)
                </button>
                <button
                    className={`sub-tab-button ${activeSubTab === 'Process2Config' ? 'active' : ''}`}
                    onClick={() => setActiveSubTab('Process2Config')}
                >
                    Process Costs <br /> (Vs, $ / unit)
                </button>
                <button
                    className={`sub-tab-button ${activeSubTab === 'Revenue1Config' ? 'active' : ''}`}
                    onClick={() => setActiveSubTab('Revenue1Config')}
                >
                    Additional Revenue Streams Quantities<br /> (Rs, units)
                </button>
                <button
                    className={`sub-tab-button ${activeSubTab === 'Revenue2Config' ? 'active' : ''}`}
                    onClick={() => setActiveSubTab('Revenue2Config')}
                >
                    Additional Revenue Streams Prices <br /> (Rs, $ / unit)
                </button>
                <button
                    className={`sub-tab-button ${activeSubTab === 'Scaling' ? 'active' : ''}`}
                    onClick={() => setActiveSubTab('Scaling')}
                >
                    + Scaling
                </button>
                <button
                    className={`sub-tab-button ${activeSubTab === 'FixedRevenueConfig' ? 'active' : ''}`}
                    onClick={() => setActiveSubTab('FixedRevenueConfig')}
                >
                    Fixed Revenue Components <br /> (RFs, $)
                </button>
            </div>
            <div className="form-content">
                {/* Version and Zone Selectors for Matrix-Based Form Values */}
                <div className="matrix-selectors">
                    <div className="version-selector">
                        <h3>Version</h3>
                        <select
                            value={versions.active}
                            onChange={e => setActiveVersion(e.target.value)}
                        >
                            {versions.list.map(version => (
                                <option key={version} value={version}>
                                    {versions.metadata[version].label}
                                </option>
                            ))}
                        </select>
                        <button onClick={() => {
                            const label = prompt("Enter name for new version:", `Version ${versions.list.length + 1}`);
                            if (label) createVersion(label);
                        }}>+ New Version</button>
                    </div>
                    <div className="zone-selector">
                        <h3>Zone</h3>
                        <select
                            value={zones.active}
                            onChange={e => setActiveZone(e.target.value)}
                        >
                            {zones.list.map(zone => (
                                <option key={zone} value={zone}>
                                    {zones.metadata[zone].label}
                                </option>
                            ))}
                        </select>
                        <button onClick={() => {
                            const label = prompt("Enter name for new zone:", `Zone ${zones.list.length + 1}`);
                            if (label) createZone(label);
                        }}>+ New Zone</button>
                    </div>
                </div>

                {/* Update GeneralFormConfig to use matrix-based properties */}
                {activeSubTab === 'ProjectConfig' && (
                    <GeneralFormConfig
                        formValues={formMatrix}
                        handleInputChange={handleInputChange}
                        version={version}
                        filterKeyword="Amount1"
                        S={S || {}}
                        setS={setS}
                        setVersion={setVersion}
                    />
                )}
                {activeSubTab === 'LoanConfig' && (
                    <GeneralFormConfig
                        formValues={formMatrix}
                        handleInputChange={handleInputChange}
                        version={version}
                        filterKeyword="Amount2"
                        S={S || {}}
                        setS={setS}
                        setVersion={setVersion}
                    />
                )}
                {activeSubTab === 'RatesConfig' && (
                    <GeneralFormConfig
                        formValues={formMatrix}
                        handleInputChange={handleInputChange}
                        version={version}
                        filterKeyword="Amount3"
                        F={F}
                        toggleF={toggleF}
                        S={S || {}}
                        setS={setS}
                        setVersion={setVersion}
                    />
                )}
                {activeSubTab === 'Process1Config' && (
                    <>
                        <GeneralFormConfig
                            formValues={formMatrix}
                            handleInputChange={handleInputChange}
                            version={version}
                            filterKeyword="Amount4"
                            V={V}
                            setV={setV}
                            R={R}
                            setR={setR}
                            toggleR={toggleR}
                            toggleV={toggleV}
                            S={S || {}}
                            setS={setS}
                            setVersion={setVersion}
                            summaryItems={finalResults.Amount4} // Pass the stored results
                        />
                        <ExtendedScaling
                            baseCosts={scalingBaseCosts.Amount4 || []}
                            onScaledValuesChange={handleScaledValuesChange}
                            initialScalingGroups={scalingGroups.filter(g => g._scalingType === 'Amount4')}
                            onScalingGroupsChange={(newGroups) => {
                                const otherGroups = scalingGroups.filter(g => g._scalingType !== 'Amount4');
                                const updatedGroups = newGroups.map(g => ({...g, _scalingType: 'Amount4'}));
                                handleScalingGroupsChange([...otherGroups, ...updatedGroups]);
                            }}
                            filterKeyword="Amount4"
                            V={V}
                            R={R}
                            toggleV={toggleV}
                            toggleR={toggleR}
                            onFinalResultsGenerated={handleFinalResultsGenerated} // Add this callback
                            activeGroupIndex={activeScalingGroups.Amount4 || 0}
                            onActiveGroupChange={handleActiveGroupChange}
                        />
                    </>
                )}
                {/* Other tabs remain similar but use formMatrix instead of formValues */}
                {/* ... The rest of your tabs */}

                <div className="form-panel-container" style={{gap: 0, margin: 0, padding: 0}}>
                <div className="form-action-buttons" style={{gap: 0}}>
                    <div className="button-row config-row" style={{marginBottom: 0, padding: 0}}>
                        <div className="tooltip-container">
                            <button
                                type="button"
                                onClick={() => loadConfiguration(version)}
                                style={{padding: "5px 8px"}}
                            >
                                Load Configuration
                            </button>
                        </div>
                        <div className="version-input-container">
                            <input
                                id="versionNumber"
                                type="number"
                                className="version-input"
                                placeholder="1"
                                value={version}
                                onChange={handleVersionChange}
                                style={{height: "25px"}}
                            />
                        </div>
                    </div>

                    <div className="button-row checkbox-row" style={{marginTop: 0, marginBottom: 0, padding: 0}}>
                        <label>
                            <input
                                type="checkbox"
                                checked={remarks === 'on'}
                                onChange={toggleRemarks}
                            />
                            Remarks
                        </label>
                        <label>
                            <input
                                type="checkbox"
                                checked={customizedFeatures === 'on'}
                                onChange={toggleCustomizedFeatures}
                            />
                            Customized Features
                        </label>
                    </div>

                    <div className="button-row visualization-row" style={{marginTop: 0, marginBottom: 0, padding: 0}}>
                        <div className="tooltip-container">
                            <button
                                onClick={handleRunPNG}
                                style={{padding: "5px 8px"}}
                            >
                                Generate PNG Plots
                            </button>
                        </div>
                        <div className="tooltip-container">
                            <button
                                type="button"
                                onClick={handleRunSub}
                                style={{padding: "5px 8px"}}
                            >
                                Generate Dynamic Plots
                            </button>
                        </div>
                    </div>

                    <div className="step-content" style={{marginTop: 0, marginBottom: 0, padding: 0}}>
                        <button
                          className="primary-action"
                          onClick={createNewBatch}
                          disabled={batchRunning || analysisRunning}
                          style={{padding: "5px 8px", margin: 0}}
                        >
                          {batchRunning ? (
                            <span className="loading-text">Creating New Batch</span>
                          ) : (
                            <span className="action-text">Create New Batch</span>
                          )}
                        </button>
                        <button
                          className="secondary-action"
                          onClick={RemoveBatch}
                          disabled={batchRunning || analysisRunning}
                          style={{padding: "5px 8px", margin: 0}}
                        >
                          <span className="action-text">Remove Current Batch</span>
                        </button>
                    </div>

                    <div className="button-row practical-row" style={{marginTop: 0, padding: 0}}>
                        <div className="tooltip-container">
                            <button
                                onClick={handleRunCFA}
                                style={{padding: "5px 8px"}}
                            >
                                Run CFA
                            </button>
                            <button
                                onClick={handleRunSensitivity}
                                style={{padding: "5px 8px"}}
                            >
                                Run Sensitivity
                            </button>
                            <button
                                onClick={handleRunSensitivity}
                                style={{padding: "5px 8px"}}
                            >
                                Visualize Sensitivity
                            </button>
                        </div>
                        <div className="tooltip-container">
                            <button
                                onClick={() => setMonitoringActive(!monitoringActive)}
                                className={monitoringActive ? 'active-monitoring' : ''}
                                style={{padding: "5px 8px"}}
                            >
                                {monitoringActive ? 'Hide Monitoring' : 'Show Monitoring'}
                            </button>
                        </div>
                        <div className="tooltip-container">
                            <button
                                onClick={handleSubmitCompleteSet}
                                style={{padding: "5px 8px"}}
                            >
                                Submit Complete Set
                            </button>
                        </div>
                        <div className="tooltip-container">
                            <button
                                type="button"
                                onClick={handleReset}
                                style={{padding: "5px 8px"}}
                            >
                                Reset
                            </button>
                        </div>

                        {/* Matrix-specific actions */}
                        <div className="tooltip-container">
                            <button
                                onClick={syncWithBackend}
                                disabled={isSyncing}
                                style={{padding: "5px 8px"}}
                            >
                                {isSyncing ? 'Syncing...' : 'Sync with Backend'}
                            </button>
                        </div>
                        <div className="tooltip-container">
                            <button
                                onClick={exportMatrixState}
                                style={{padding: "5px 8px"}}
                            >
                                Export Matrix
                            </button>
                        </div>
                        <div className="tooltip-container">
                            <input
                                type="file"
                                id="importMatrix"
                                accept=".json"
                                style={{ display: 'none' }}
                                onChange={(e) => {
                                    if (e.target.files && e.target.files.length > 0) {
                                        importMatrixState(e.target.files[0]);
                                    }
                                }}
                            />
                            <button
                                onClick={() => document.getElementById('importMatrix').click()}
                                style={{padding: "5px 8px"}}
                            >
                                Import Matrix
                            </button>
                        </div>

                        {/* Reset Options Popup */}
                        <ResetOptionsPopup
                            show={showResetOptions}
                            options={resetOptions}
                            onOptionChange={handleResetOptionChange}
                            onConfirm={handleResetConfirm}
                            onCancel={handleResetCancel}
                        />

                        {/* Run Options Popup */}
                        <RunOptionsPopup
                            show={showRunOptions}
                            options={runOptions}
                            onOptionChange={handleRunOptionChange}
                            onConfirm={handleRunConfirm}
                            onCancel={handleRunCancel}
                        />

                        {/* Dynamic Plots Options Popup */}
                        <DynamicPlotsOptionsPopup
                            show={showDynamicPlotsOptions}
                            options={subDynamicPlots}
                            onOptionChange={handleDynamicPlotsOptionChange}
                            onConfirm={() => {
                                handleDynamicPlotsConfirm();
                                executeDynamicPlotsGeneration();
                            }}
                            onCancel={handleDynamicPlotsCancel}
                        />
                    </div>
                </div>
                </div>
                {monitoringActive && (
                    <CalculationMonitor
                        selectedVersions={selectedVersions}
                        updatePrice={updatePrice}
                        isActive={monitoringActive}
                        currentVersion={version}
                        isSensitivity={isMonitoringSensitivity}
                        selectedProperties={selectedProperties}
                        remarks={remarks}
                        customizedFeatures={customizedFeatures}
                        onChange={() => {}} // Adding empty function to satisfy prop requirement
                    />
                )}
                {/* Rest of form content remains the same */}
                {/* ... */}
            </div>
        </div>
    );

    // ... rest of your component

    return (
        <div className="HomePage">
            {/* Your existing code */}
            <div className="main-content">
                {/* Your existing code */}
                <div className="content-container">
                    {activeTab !== 'AboutUs' && activeTab !== 'TestingZone' &&
                        (
                        <>
                            <SensitivityMonitor
                                S={S}
                                setS={setS}
                                version={version}
                                activeTab={activeTab}
                            />
                            <ConfigurationMonitor
                                version={version}
                            />
                        </>
                    )}
                    <div className="HomePageTabContent">
                        {renderTabContent()}
                    </div>
                </div>
            </div>
        </div>
    );
};

const HomePage = () => {
    return <HomePageContent />;
};

export default HomePage;
```

# GeneralFormConfig.js (Updated for Matrix-Based Form Values)

```javascript
import React, { useState, useEffect, useCallback } from 'react';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import { faEdit, faCheck, faTimes, faSave, faUndo } from '@fortawesome/free-solid-svg-icons';
import axios from 'axios';
import { sensitivityActionRef } from './components/modules/SensitivityMonitor';
import FactualPrecedence from './components/find_factual_precedence/components/modules/FactualPrecedence/index';
// Import label references for reset functionality
import * as labelReferences from './utils/labelReferences';
import Popup from './components/modules/Efficacy';

/**
 * GeneralFormConfig Component - Updated for Matrix-Based Form Values
 * Handles configuration of form values, labels, and related settings
 */
const GeneralFormConfig = ({
                             formValues, // Now contains formMatrix structure
                             handleInputChange,
                             version,
                             filterKeyword,
                             V, toggleV,
                             R, toggleR,
                             F, toggleF,
                             RF, toggleRF,
                             S, setS,
                             setVersion,
                             summaryItems,
                           }) => {
  // Get icon mapping from formValues which now contains matrix structure
  const { iconMapping } = formValues;

  //--------------------------------------------------------------------------
  // STATE MANAGEMENT
  //--------------------------------------------------------------------------
  const [showPopup, setShowPopup] = useState(false);
  const [popupPosition, setPopupPosition] = useState({ top: 0, left: 0 });
  const [selectedItemId, setSelectedItemId] = useState();
  const [updateStatus, setUpdateStatus] = useState('');
  const [isUpdating, setIsUpdating] = useState(false);

  // Factual Precedence state
  const [showFactualPrecedence, setShowFactualPrecedence] = useState(false);
  const [factualPrecedencePosition, setFactualPrecedencePosition] = useState({ top: 0, left: 0 });
  const [factualItemId, setFactualItemId] = useState(null);

  // Label management state
  const [editingLabel, setEditingLabel] = useState(null);
  const [tempLabel, setTempLabel] = useState('');
  const [originalLabels, setOriginalLabels] = useState({});
  const [editedLabels, setEditedLabels] = useState({});

  //--------------------------------------------------------------------------
  // HELPER FUNCTIONS - Convert keys to specific numbering schemes
  //--------------------------------------------------------------------------
  // Get plant lifetime value for efficacy calculations
  const getLatestPlantLifetime = (formValues) => {
    // Extract the active version & zone
    const activeVersion = formValues.versions ? formValues.versions.active : 'v1';
    const activeZone = formValues.zones ? formValues.zones.active : 'z1';

    // Find plant lifetime in matrix
    const lifetimeParam = Object.values(formValues.formMatrix || formValues)
        .find(item => item.id === 'plantLifetimeAmount10');

    if (lifetimeParam) {
  I'll continue updating the GeneralFormConfig.js file to work with the new matrix-based form values structure.

  ```javascript
        // Get value from matrix structure if available
        if (lifetimeParam.matrix && activeVersion && activeZone) {
          return lifetimeParam.matrix[activeVersion][activeZone] || 40;
        }
        // Fall back to direct value if matrix not available
        return lifetimeParam.value || 40;
      }
      return 40; // Default if not found
    };

    // Get S parameter number (used for sensitivity analysis)
    const getSNumber = (key) => {
      const match = key.match(/Amount(\d+)/);
      if (!match) return null;

      const num = parseInt(match[1]);
      if (num >= 10 && num <= 84) return `S${num}`; // S10-S79
      return null;
    };

    // Get V parameter number (variable parameters)
    const getVNumber = (vAmountNum) => {
      const num = parseInt(vAmountNum);
      if (num >= 40 && num <= 49) return `V${num - 39}`;
      if (num >= 50 && num <= 59) return `V${num - 49}`;
      return null;
    };

    // Get R parameter number (rate parameters)
    const getRNumber = (rAmountNum) => {
      const num = parseInt(rAmountNum);
      if (num >= 50 && num <= 69) return `R${num - 59}`;
      if (num >= 50 && num <= 79) return `R${num - 69}`;
      return null;
    };

    // Get F parameter number (factor parameters)
    const getFNumber = (key) => {
      const match = key.match(/Amount(\d+)/);
      if (!match) return null;

      const num = parseInt(match[1]);
      if (num >= 34 && num <= 38) return `F${num - 33}`;
      return null;
    };

    // Get RF parameter number (fixed revenue parameters)
    const getRFNumber = (key) => {
      const match = key.match(/Amount(\d+)/);
      if (!match) return null;

      const num = parseInt(match[1]);
      if (num >= 80 && num <= 84) return `RF${num - 79}`;
      return null;
    };

    //--------------------------------------------------------------------------
    // SUMMARY ITEM HANDLING
    //--------------------------------------------------------------------------
    // Get final calculated value from summary items
    const getFinalResultValue = (itemId) => {
      if (!summaryItems || summaryItems.length === 0) return null;

      const summaryItem = summaryItems.find(item => item.id === itemId);
      return summaryItem ? summaryItem.finalResult : null;
    };

    //--------------------------------------------------------------------------
    // FORM ITEM PROCESSING
    //--------------------------------------------------------------------------
    // Transform form values into displayable items with appropriate metadata
    const formItems = Object.keys(formValues.formMatrix || formValues)
        .filter((key) => key.includes(filterKeyword))
        .map((key) => {
          const param = formValues.formMatrix ? formValues.formMatrix[key] : formValues[key];

          // For matrix-based form values, extract dynamic appendix information
          let vKey = null, rKey = null, fKey = null, rfKey = null, sKey = null;

          if (param.dynamicAppendix && param.dynamicAppendix.itemState) {
            // Extract from dynamic appendix if available
            vKey = param.dynamicAppendix.itemState.vKey;
            rKey = param.dynamicAppendix.itemState.rKey;
            fKey = param.dynamicAppendix.itemState.fKey;
            rfKey = param.dynamicAppendix.itemState.rfKey;
            sKey = param.dynamicAppendix.itemState.sKey;
          } else {
            // Fall back to older method
            vKey = key.includes('vAmount') ? getVNumber(key.replace('vAmount', '')) : null;
            rKey = key.includes('rAmount') ? getRNumber(key.replace('rAmount', '')) : null;
            fKey = getFNumber(key);
            rfKey = getRFNumber(key);
            sKey = getSNumber(key);
          }

          // Handle matrix-based form values
          let value, step, remarks, efficacyPeriod, placeholder, type, options;

          if (formValues.versions && formValues.zones) {
            // Get active version and zone
            const activeVersion = formValues.versions.active;
            const activeZone = formValues.zones.active;

            // Extract value from matrix
            value = param.matrix && param.matrix[activeVersion] && param.matrix[activeVersion][activeZone] !== undefined
              ? param.matrix[activeVersion][activeZone]
              : param.placeholder || '';

            // Extract other properties
            step = param.step;
            remarks = param.remarks;
            efficacyPeriod = param.efficacyPeriod;
            placeholder = param.placeholder;
            type = param.type;
            options = param.options;
          } else {
            // Fallback for non-matrix form values
            value = param.value;
            step = param.step;
            remarks = param.remarks;
            efficacyPeriod = param.efficacyPeriod;
            placeholder = param.placeholder;
            type = param.type;
            options = param.options;
          }

          return {
            id: key,
            label: param.label,
            value,
            step,
            remarks,
            efficacyPeriod,
            placeholder,
            type,
            options,
            vKey,
            rKey,
            fKey,
            rfKey,
            sKey
          };
        });

    //--------------------------------------------------------------------------
    // LABEL MANAGEMENT FUNCTIONS
    //--------------------------------------------------------------------------
    // Store original labels when component mounts
    useEffect(() => {
      if (Object.keys(originalLabels).length === 0) {
        const labels = {};
        // Check if we're using the matrix structure
        if (formValues.formMatrix) {
          Object.entries(formValues.formMatrix).forEach(([key, value]) => {
            labels[key] = value.label;
          });
        } else {
          Object.entries(formValues).forEach(([key, value]) => {
            labels[key] = value.label;
          });
        }
        setOriginalLabels(labels);
      }
    }, [formValues, originalLabels]);

    // Begin editing a label
    const handleLabelEdit = (itemId) => {
      setEditingLabel(itemId);
      // Get the current label from matrix or regular structure
      const currentLabel = formValues.formMatrix
        ? formValues.formMatrix[itemId].label
        : formValues[itemId].label;
      setTempLabel(currentLabel);
    };

    // Cancel label editing
    const handleCancelEdit = () => {
      setEditingLabel(null);
      setTempLabel('');
    };

    // Save edited label locally
    const handleLabelSave = (itemId) => {
      handleInputChange({ target: { value: tempLabel } }, itemId, 'label');
      setEditedLabels(prev => ({ ...prev, [itemId]: true }));
      setEditingLabel(null);
      setUpdateStatus('Label saved locally - remember to update form');
      setTimeout(() => setUpdateStatus(''), 3000);
    };

    const [tempLabel_container] = useState({});
    // useEffect to be notified everytime handleLabelSave is called update tempLabel_container
    useEffect(() => {
      // This effect runs whenever editedLabels changes (from handleLabelSave)
      if (Object.keys(editedLabels).length > 0) {
        // Store the saved label in tempLabel_container
        const itemId = Object.keys(editedLabels).find(id => editedLabels[id]);
        if (itemId && tempLabel_container.current) {
          tempLabel_container.current[itemId] = tempLabel;
        }
      }
    }, [editedLabels, tempLabel, tempLabel_container]);

    // Update all edited labels to server
    const handleUpdateFormLabels = async () => {
      try {
        setIsUpdating(true);
        setUpdateStatus('Updating form labels...');

        const updates = {};
        Object.keys(editedLabels).forEach(key => {
          // Handle matrix-based form values
          if (formValues.formMatrix && formValues.formMatrix[key]) {
            const param = formValues.formMatrix[key];
            const activeVersion = formValues.versions.active;
            const activeZone = formValues.zones.active;

            updates[key] = {
              label: param.label,
              value: param.matrix[activeVersion]?.[activeZone],
              labelEdited: true // Flag to indicate the label was edited
            };
          }
          // Fall back to original form values structure
          else if (formValues[key]) {
            updates[key] = {
              label: formValues[key].label,
              value: formValues[key].value,
              labelEdited: true // Flag to indicate the label was edited
            };
          }
        });

        if (Object.keys(updates).length === 0) {
          setUpdateStatus('No edited labels to update');
          setIsUpdating(false);
          setTimeout(() => setUpdateStatus(''), 3000);
          return;
        }

        const response = await axios.post('http://localhost:3060/api/update-form-values', { updates });

        if (response.data.success) {
          // Clear tracking after successful update
          setEditedLabels({});
          setUpdateStatus(`${Object.keys(updates).length} labels updated successfully`);
          setTimeout(() => setUpdateStatus(''), 3000);
        } else {
          throw new Error(response.data.message);
        }
      } catch (error) {
        console.error('Update failed:', error);
        setUpdateStatus(`Update failed: ${error.message}`);
        setTimeout(() => setUpdateStatus(''), 3000);
      } finally {
        setIsUpdating(false);
      }
    };

    // Reset all labels to original values using labelReferences
    const handleResetLabels = async () => {
      if (window.confirm('Reset all labels and default values to original values?')) {
        // First, reset labels locally
        const updatedLabels = {};
        Object.entries(labelReferences.propertyMapping).forEach(([key, label]) => {
          // Handle matrix-based form values
          if (formValues.formMatrix && formValues.formMatrix[key]) {
            handleInputChange({ target: { value: label } }, key, 'label');

            // Also reset default values if available
            if (labelReferences.defaultValues && labelReferences.defaultValues[key] !== undefined) {
              // For matrix-based values, update in the active version and zone
              const activeVersion = formValues.versions.active;
              const activeZone = formValues.zones.active;

              // Use updateParameterValue if it exists in the form values object
              if (formValues.updateParameterValue) {
                formValues.updateParameterValue(key, labelReferences.defaultValues[key], activeVersion, activeZone);
              } else {
                // Fallback to handleInputChange
                handleInputChange({ target: { value: labelReferences.defaultValues[key] } }, key, 'value');
              }
            }

            // Mark this label as edited so we can update the server
            updatedLabels[key] = true;
          }
          // Fall back to original form values structure
          else if (formValues[key]) {
            handleInputChange({ target: { value: label } }, key, 'label');

            // Also reset default values if available
            if (labelReferences.defaultValues && labelReferences.defaultValues[key] !== undefined) {
              handleInputChange({ target: { value: labelReferences.defaultValues[key] } }, key, 'value');
            }

            // Mark this label as edited so we can update the server
            updatedLabels[key] = true;
          }
        });

        // Update the server with all reset values
        try {
          setIsUpdating(true);
          setUpdateStatus('Updating form with original values...');

          const updates = {};
          Object.keys(updatedLabels).forEach(key => {
            // Handle matrix-based form values
            if (formValues.formMatrix && formValues.formMatrix[key]) {
              const param = formValues.formMatrix[key];
              const activeVersion = formValues.versions.active;
              const activeZone = formValues.zones.active;

              updates[key] = {
                label: param.label,
                value: param.matrix[activeVersion]?.[activeZone],
                labelEdited: true // Flag to indicate the label was reset
              };
            }
            // Fall back to original form values structure
            else if (formValues[key]) {
              updates[key] = {
                label: formValues[key].label,
                value: formValues[key].value,
                labelEdited: true // Flag to indicate the label was reset
              };
            }
          });

          if (Object.keys(updates).length > 0) {
            const response = await axios.post('http://localhost:3060/api/update-form-values', { updates });

            if (response.data.success) {
              setUpdateStatus(`Reset complete: ${Object.keys(updates).length} items restored to original values`);
            } else {
              throw new Error(response.data.message);
            }
          } else {
            setUpdateStatus('No items to reset');
          }
        } catch (error) {
          console.error('Reset failed:', error);
          setUpdateStatus(`Reset failed: ${error.message}`);
        } finally {
          setIsUpdating(false);
          setEditedLabels({});
          setTimeout(() => setUpdateStatus(''), 3000);
        }
      }
    };

    //--------------------------------------------------------------------------
    // INPUT HANDLERS
    //--------------------------------------------------------------------------
    // Handle increment button click
    const handleIncrement = (itemId) => {
      // Handle matrix-based form values
      if (formValues.formMatrix) {
        const item = formValues.formMatrix[itemId];
        const activeVersion = formValues.versions.active;
        const activeZone = formValues.zones.active;

        // Get current value from matrix
        const currentValue = item.matrix[activeVersion]?.[activeZone] || 0;
        const newValue = parseFloat(currentValue) + parseFloat(item.step || 1);

        // Use updateParameterValue if it exists
        if (formValues.updateParameterValue) {
          formValues.updateParameterValue(itemId, newValue, activeVersion, activeZone);
        } else {
          // Fallback to handleInputChange
          handleInputChange({ target: { value: newValue } }, itemId, 'value');
        }
      }
      // Fall back to original form values structure
      else {
        const item = formValues[itemId];
        const newValue = parseFloat(item.value) + parseFloat(item.step);
        handleInputChange({ target: { value: newValue } }, itemId, 'value');
      }
    };

    // Handle decrement button click
    const handleDecrement = (itemId) => {
      // Handle matrix-based form values
      if (formValues.formMatrix) {
        const item = formValues.formMatrix[itemId];
        const activeVersion = formValues.versions.active;
        const activeZone = formValues.zones.active;

        // Get current value from matrix
        const currentValue = item.matrix[activeVersion]?.[activeZone] || 0;
        const newValue = parseFloat(currentValue) - parseFloat(item.step || 1);

        // Use updateParameterValue if it exists
        if (formValues.updateParameterValue) {
          formValues.updateParameterValue(itemId, newValue, activeVersion, activeZone);
        } else {
          // Fallback to handleInputChange
          handleInputChange({ target: { value: newValue } }, itemId, 'value');
        }
      }
      // Fall back to original form values structure
      else {
        const item = formValues[itemId];
        const newValue = parseFloat(item.value) - parseFloat(item.step);
        handleInputChange({ target: { value: newValue } }, itemId, 'value');
      }
    };

    // Handle schedule/efficacy button click
    const handleScheduleClick = (e, itemId) => {
      const rect = e.target.getBoundingClientRect();
      setPopupPosition({
        top: rect.top + window.scrollY + 61.8,
        left: rect.left + rect.width + 1000,
      });
      setSelectedItemId(itemId);

      const latestPlantLifetime = getLatestPlantLifetime(formValues);

      // Handle efficacy period updates
      if (formValues.formMatrix) {
        // For matrix-based form values, use the efficacyPeriod directly
        const efficacyPeriod = formValues.formMatrix[itemId].efficacyPeriod || {};
        // Update the efficacy period end value
        handleInputChange({ target: { value: latestPlantLifetime } }, itemId, 'efficacyPeriod', 'end');
      } else {
        // For regular form values
        const efficacyPeriod = formValues[itemId].efficacyPeriod || {};
        handleInputChange({ target: { value: latestPlantLifetime } }, itemId, 'efficacyPeriod', 'end');
      }

      setShowPopup(true);
    };

    // FIXED: Factual precedence handlers
    const handleFactualPrecedenceClick = (event, itemId) => {
      event.preventDefault();
      const rect = event.currentTarget.getBoundingClientRect();
      // Calculate position relative to viewport with offset and boundary checking
      setFactualPrecedencePosition(() => {
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;

        // Default position (below the element)
        let top = rect.bottom + window.scrollY + 10; // 10px padding
        let left = rect.left + window.scrollX;

        // Right offset (add 300px to the right)
        left += 300;

        // Boundary checking (keep popup within viewport)
        const popupWidth = 550; // From CSS width
        const popupHeight = 400; // Estimated height

        // Adjust if would go off right edge
        if (left + popupWidth > viewportWidth) {
          left = viewportWidth - popupWidth - 20; // 20px margin
        }

        // Adjust if would go off bottom edge
        if (top + popupHeight > viewportHeight) {
          top = rect.top + window.scrollY - popupHeight - 10; // Show above instead
        }

        return { top, left };
      });
      // Set factual item ID separately from selected item ID
      setFactualItemId(itemId);
      setShowFactualPrecedence(true);
    };

    const handleCloseFactualPrecedence = () => {
      setShowFactualPrecedence(false);
      setFactualItemId(null);
    };

    //--------------------------------------------------------------------------
    // COMPONENT RENDERING
    //--------------------------------------------------------------------------
    return (
        <>
          {/* Label Management Section */}
          <div className="labels-section">
            <button
                className="update-button"
                onClick={handleUpdateFormLabels}
                disabled={isUpdating}
            >
              <FontAwesomeIcon icon={faSave} /> {isUpdating ? 'Updating...' : 'Update Form Labels'}
            </button>
            <button
                className="reset-button"
                onClick={handleResetLabels}
            >
              <FontAwesomeIcon icon={faUndo} /> Reset Labels
            </button>
            {updateStatus && <span className="update-status">{updateStatus}</span>}
          </div>

          {/* Form Items Display */}
          {formItems.map((item) => (
              <div key={item.id} className={`form-item-container ${item.id === selectedItemId ? 'highlighted-container' : ''}`}>

                {/* Parameter Type Checkboxes (V/R/F) */}
                <div className="checkbox-section">
                  {item.vKey && (
                      <div className="checkbox-group">
                        <span className="checkbox-label">{item.vKey}</span>
                        <input
                            type="checkbox"
                            className="custom-checkbox"
                            checked={V[item.vKey] === 'on'}
                            onChange={() => toggleV(item.vKey)}
                        />
                      </div>
                  )}
                  {item.rKey && (
                      <div className="checkbox-group">
                        <span className="checkbox-label">{item.rKey}</span>
                        <input
                            type="checkbox"
                            className="custom-checkbox"
                            checked={R[item.rKey] === 'on'}
                            onChange={() => toggleR(item.rKey)}
                        />
                      </div>
                  )}
                  {item.fKey && (
                      <div className="checkbox-group">
                        <span className="checkbox-label">{item.fKey}</span>
                        <input
                            type="checkbox"
                            className="custom-checkbox"
                            checked={F[item.fKey] === 'on'}
                            onChange={() => toggleF(item.fKey)}
                        />
                      </div>
                  )}
                  {item.rfKey && (
                      <div className="checkbox-group">
                        <span className="checkbox-label">{item.rfKey}</span>
                        <input
                            type="checkbox"
                            className="custom-checkbox"
                            checked={RF[item.rfKey] === 'on'}
                            onChange={() => toggleRF(item.rfKey)}
                        />
                      </div>
                  )}
                </div>

                {/* Main Input Section */}
                <div className="main-input-section">
                  {/* Label and Icon */}
                  <div className="label-container">
                    {iconMapping[item.id] && (
                        <FontAwesomeIcon icon={iconMapping[item.id]} className="input-icon" />
                    )}
                    {editingLabel === item.id ? (
                        <div className="edit-label-container">
                          <input
                              type="text"
                              value={tempLabel}
                              onChange={(e) => setTempLabel(e.target.value)}
                              className="label-edit-input"
                          />
                          <div className="edit-actions">
                            <FontAwesomeIcon
                                icon={faCheck}
                                onClick={() => handleLabelSave(item.id)}
                                className="edit-icon save"
                            />
                            <FontAwesomeIcon
                                icon={faTimes}
                                onClick={handleCancelEdit}
                                className="edit-icon cancel"
                            />
                          </div>
                        </div>
                    ) : (
                        <div className="label-text">
                          <FontAwesomeIcon
                              icon={faEdit}
                              onClick={() => handleLabelEdit(item.id)}
                              className="edit-icon"
                          />
                          <span>{item.label}</span>
                        </div>
                    )}
                  </div>

                  {/* Numeric Input Controls */}
                  {item.type === 'number' && (
                      <div className="input-controls-section">
                        <div className="value-container">
                          <input
                              type="number"
                              id={item.id}
                              value={item.value !== undefined && item.value !== null && !isNaN(item.value) ? item.value : ''}
                              onChange={(e) => {
                                let value = parseFloat(e.target.value);
                                value = isNaN(value) ? null : value;
                                handleInputChange({ target: { value } }, item.id, 'value');
                              }}
                              className="value-input"
                              placeholder={item.placeholder}
                              step={item.step}
                          />

                          {/* Summary Results Display */}
                          {getFinalResultValue(item.id) !== null && (
                              <div className="final-result-container">
                                <span className="final-result-value">
                                  Final: {getFinalResultValue(item.id).toFixed(2)}
                                </span>
                                <span className="final-result-indicator">
                                   Summary Result
                                </span>
                              </div>
                          )}

                          <div className="increment-controls">
                            <button className="control-button1" onClick={() => handleDecrement(item.id)}>-</button>
                            <button className="control-button2" onClick={() => handleIncrement(item.id)}>+</button>
                          </div>
                        </div>

                        {/* Step Value Input */}
                        <div className="step-container">
                          <input
                              type="number"
                              id={`${item.id}-step`}
                              value={item.step !== undefined && item.step !== null && !isNaN(item.step) ? item.step : ''}
                              onChange={(e) => {
                                let step = parseFloat(e.target.value);
                                step = isNaN(step) ? '' : step;
                                handleInputChange({ target: { value: step } }, item.id, 'step');
                              }}
                              className="step-input"
                              placeholder="Step Value"
                          />
                        </div>

                        {/* Remarks Field */}
                        <div className="remarks-container">
                          <input
                              type="text"
                              id={`${item.id}-remarks`}
                              value={item.remarks || ''}
                              onChange={(e) => handleInputChange({ target: { value: e.target.value } }, item.id, 'remarks')}
                              placeholder="Add remarks"
                              className="remarks-input remarks-important"
                          />
                        </div>

                        {/* Action Buttons */}
                        <div className="action-buttons">
                          {/* Sensitivity Configuration */}
                          {item.sKey && (
                              <button
                                  className="action-button-sensitivity"
                                  onClick={() => {
                                    if (sensitivityActionRef.current) {
                                      // First enable the parameter
                                      sensitivityActionRef.current.toggleParameterEnabled(item.sKey);

                                      // Then open configuration panel with a slight delay to ensure state updates
                                      setTimeout(() => {
                                        sensitivityActionRef.current.openParameterDetails(item.sKey);
                                      }, 50);
                                    } else {
                                      console.warn("Sensitivity configuration is not available");
                                    }
                                  }}
                              >
                                Configure Sensitivity
                              </button>
                          )}
                          <button
                              className="action-button-efficacy"
                              onClick={(e) => handleScheduleClick(e, item.id)}
                          >
                            Specify Efficacy Period
                          </button>
                          <button
                              className="action-button-factual"
                              onClick={(e) => handleFactualPrecedenceClick(e, item.id)}
                          >
                            Find Factual Precedence
                          </button>
                        </div>
                      </div>
                  )}

                  {/* Select Input Controls */}
                  {item.type === 'select' && (
                      <div className="input-controls-section">
                        <div className="value-container">
                          <select
                              id={item.id}
                              value={item.value || ''}
                              onChange={(e) => handleInputChange(e, item.id, 'value')}
                              className="select-input"
                          >
                            {item.options.map((option, index) => (
                                <option key={index} value={option}>{option}</option>
                            ))}
                          </select>
                        </div>

                        {/* Remarks Field */}
                        <div className="remarks-container">
                          <input
                              type="text"
                              id={`${item.id}-remarks`}
                              value={item.remarks || ''}
                              onChange={(e) => handleInputChange({ target: { value: e.target.value } }, item.id, 'remarks')}
                              placeholder="Add remarks"
                              className="remarks-input remarks-important"
                          />
                        </div>

                        {/* Action Buttons */}
                        <div className="action-buttons">
                          {/* Sensitivity Configuration */}
                          {item.sKey && (
                              <button
                                  className="action-button-sensitivity"
                                  onClick={() => {
                                    if (sensitivityActionRef.current) {
                                      // First enable the parameter
                                      sensitivityActionRef.current.toggleParameterEnabled(item.sKey);

                                      // Then open configuration panel with a slight delay to ensure state updates
                                      setTimeout(() => {
                                        sensitivityActionRef.current.openParameterDetails(item.sKey);
                                      }, 50);
                                    } else {
                                      console.warn("Sensitivity configuration is not available");
                                    }
                                  }}
                              >
                                Configure Sensitivity
                              </button>
                          )}
                          <button
                              className="action-button-efficacy"
                              onClick={(e) => handleScheduleClick(e, item.id)}
                          >
                            Specify Efficacy Period
                          </button>
                          <button
                              className="action-button-factual"
                              onClick={(e) => handleFactualPrecedenceClick(e, item.id)}
                          >
                            Find Factual Precedence
                          </button>
                        </div>
                      </div>
                  )}
                </div>
              </div>
          ))}

          {/* Efficacy Popup */}
          {selectedItemId && (
              <Popup
                  show={showPopup}
                  position={popupPosition}
                  onClose={() => {
                    setShowPopup(false);
                    setSelectedItemId(null); // Reset the selectedItemId to remove highlighting
                  }}
                  formValues={formValues}
                  handleInputChange={handleInputChange}
                  id={selectedItemId}
                  onVersionChange={(newVersion) => setVersion(newVersion)}
                  version={version}
                  itemId={selectedItemId}
              />
          )}

          {/* Factual Precedence Popup - Moved outside the loop */}
          {showFactualPrecedence && (
              <FactualPrecedence
                  show={showFactualPrecedence}
                  position={factualPrecedencePosition}
                  onClose={handleCloseFactualPrecedence}
                  formValues={formValues}
                  id={factualItemId}
                  handleInputChange={handleInputChange}
              />
          )}
        </>
    );
  };

  export default GeneralFormConfig;
  ```

  # Server.js (Master Server)

  ```javascript
  const { spawn } = require('child_process');
  const path = require('path');
  const express = require('express');
  const cors = require('cors');

  // Create an Express app for the master server
  const app = express();
  app.use(cors());

  // Define the services to start
  const services = [
    {
      name: 'Parameter Append Server',
      command: 'node',
      args: [path.join(__dirname, 'submit_parameter_append.js')],
      port: 3040
    },
    {
      name: 'Complete Set Server',
      command: 'node',
      args: [path.join(__dirname, 'submitCompleteSet.js')],
      port: 3052
    },
    {
      name: 'Formatter Server',
      command: 'python',
      args: [path.join(__dirname, 'formatter.py'), '1', 'server'],
      port: 3050
    },
    {
      name: 'Module1 Server',
      command: 'python',
      args: [path.join(__dirname, 'module1.py'), '1', 'server'],
      port: 3051
    },
    {
      name: 'Config Modules Server',
      command: 'python',
      args: [path.join(__dirname, 'config_modules.py'), '1', 'server'],
      port: 3053
    },
    {
      name: 'Table Server',
      command: 'python',
      args: [path.join(__dirname, 'Table.py'), '1', 'server'],
      port: 3054
    }
  ];

  // Function to start a service
  function startService(service) {
    console.log(`Starting ${service.name} on port ${service.port}...`);

    const process = spawn(service.command, service.args);

    process.stdout.on('data', (data) => {
      console.log(`[${service.name}] ${data}`);
    });

    process.stderr.on('data', (data) => {
      console.error(`[${service.name}] Error: ${data}`);
    });

    process.on('close', (code) => {
      console.log(`${service.name} process exited with code ${code}`);
      // Restart the service if it crashes
      setTimeout(() => {
        console.log(`Restarting ${service.name}...`);
        startService(service);
      }, 5000);
    });

    return process;
  }

  // Start all services
  const serviceProcesses = services.map(service => startService(service));

  // Setup master server endpoints
  app.get('/', (req, res) => {
    res.send('Matrix Calculation Backend Server is running');
  });

  // Endpoint to check the status of all services
  app.get('/status', async (req, res) => {
    try {
      const statuses = await Promise.all(services.map(async (service) => {
        try {
          const response = await fetch(`http://localhost:${service.port}/health`);
          return {
            name: service.name,
            port: service.port,
            status: response.ok ? 'UP' : 'DOWN',
            message: response.ok ? await response.text() : 'Service not responding'
          };
        } catch (error) {
          return {
            name: service.name,
            port: service.port,
            status: 'DOWN',
            message: error.message
          };
        }
      }));

      res.json({
        masterServer: {
          status: 'UP',
          port: process.env.PORT || 3060
        },
        services: statuses
      });
    } catch (error) {
      res.status(500).json({
        error: 'Error checking service statuses',
        message: error.message
      });
    }
  });

  // Handle graceful shutdown
  function shutdown() {
    console.log('Shutting down all services...');

    serviceProcesses.forEach((process, index) => {
      console.log(`Stopping ${services[index].name}...`);
      process.kill();
    });

    console.log('All services stopped. Exiting...');
    process.exit(0);
  }

  // Handle various termination signals
  process.on('SIGINT', shutdown);
  process.on('SIGTERM', shutdown);
  process.on('SIGHUP', shutdown);

  // Start the master server
  const PORT = process.env.PORT || 3060;
  app.listen(PORT, () => {
    console.log(`Master server running on port ${PORT}`);
    console.log('All services have been started. Press Ctrl+C to stop all services and exit.');
  });
  ```

  # Migration Guide: From Form Values to Matrix-Based Form Values

  ## Overview

  This migration guide will help you update your codebase to use the new matrix-based form values system. The new system provides enhanced functionality for handling multiple versions, zones, and efficacy periods for form parameters.

  ## Key Changes

  1. **Form Structure**: Changed from flat key-value pairs to a matrix structure with versions and zones
  2. **Parameter Access**: Updated methods for getting and setting parameter values
  3. **Submission Logic**: New service for submitting matrix-based data to backend services
  4. **API Integration**: RESTful endpoints for all computational modules

  ## Step-by-step Migration Instructions

  ### 1. Update Import Statements

  ```javascript
  // Before
  import useFormValues from './useFormValues';

  // After
  import useMatrixFormValues from './useMatrixFormValues';
  ```

  ### 2. Update Hook Usage

  ```javascript
  // Before
  const formValuesHook = useFormValues();

  // After
  const matrixFormValuesHook = useMatrixFormValues();
  ```

  ### 3. Update Parameter Access

  ```javascript
  // Before - Direct property access
  const paramValue = formValues[paramId].value;

  // After - Using getter methods
  const paramValue = getParameterValue(paramId);
  // Or for specific version/zone
  const paramValue = getParameterValue(paramId, 'v2', 'z1');
  ```

  ### 4. Update Parameter Updates

  ```javascript
  // Before
  handleInputChange({ target: { value: newValue } }, paramId, 'value');

  // After - Using matrix update methods
  updateParameterValue(paramId, newValue);
  // Or for specific version/zone
  updateParameterValue(paramId, newValue, 'v2', 'z1');
  ```

  ### 5. Version & Zone Management

  Add UI components for version and zone management:

  ```jsx
  <div className="matrix-selectors">
    {/* Version Selector */}
    <div className="version-selector">
      <h3>Version</h3>
      <select
        value={versions.active}
        onChange={e => setActiveVersion(e.target.value)}
      >
        {versions.list.map(version => (
          <option key={version} value={version}>
            {versions.metadata[version].label}
          </option>
        ))}
      </select>
      <button onClick={() => {
        const label = prompt("Enter name for new version:", `Version ${versions.list.length + 1}`);
        if (label) createVersion(label);
      }}>+ New Version</button>
    </div>

    {/* Zone Selector */}
    <div className="zone-selector">
      <h3>Zone</h3>
      <select
        value={zones.active}
        onChange={e => setActiveZone(e.target.value)}
      >
        {zones.list.map(zone => (
          <option key={zone} value={zone}>
            {zones.metadata[zone].label}
          </option>
        ))}
      </select>
      <button onClick={() => {
        const label = prompt("Enter name for new zone:", `Zone ${zones.list.length + 1}`);
        if (label) createZone(label);
      }}>+ New Zone</button>
    </div>
  </div>
  ```

  ### 6. Efficacy Period Management

  Update efficacy period handling:

  ```javascript
  // Before
  handleInputChange({ target: { value: startValue } }, paramId, 'efficacyPeriod', 'start');
  handleInputChange({ target: { value: endValue } }, paramId, 'efficacyPeriod', 'end');

  // After - Using dedicated method
  updateEfficacyPeriod(paramId, startValue, endValue);
  ```

  ### 7. Backend Service Integration

  Add the MatrixSubmissionService for submitting data to backend:

  ```javascript
  import MatrixSubmissionService from './MatrixSubmissionService';

  // Initialize the service
  const submissionService = new MatrixSubmissionService();

  // Submit form values
  const handleSubmit = async () => {
    try {
      // Get the active version
      const versionId = versions.active;

      // Submit the form values
      const response = await submissionService.submitMatrixFormValues(
        matrixFormValuesHook,
        versionId
      );

      console.log('Submission result:', response);
    } catch (error) {
      console.error('Error during form submission:', error);
    }
  };
  ```

  ### 8. Importing/Exporting Matrix State

  Add UI elements for importing and exporting matrix state:

  ```jsx
  <div className="matrix-actions">
    <input
      type="file"
      id="importMatrix"
      accept=".json"
      style={{ display: 'none' }}
      onChange={(e) => {
        if (e.target.files && e.target.files.length > 0) {
          importMatrixState(e.target.files[0]);
        }
      }}
    />
    <button onClick={() => document.getElementById('importMatrix').click()}>
      Import Matrix
    </button>
    <button onClick={exportMatrixState}>
      Export Matrix
    </button>
  </div>
  ```

  ### 9. Start the Master Server

  Run the master server to start all required services:

  ```bash
  node server.js
  ```

  This will start the following services:
  - Parameter Append Server (Port 3040)
  - Complete Set Server (Port 3052)
  - Formatter Server (Port 3050)
  - Module1 Server (Port 3051)
  - Config Modules Server (Port 3053)
  - Table Server (Port 3054)
  - Master Server (Port 3060)

  ## Troubleshooting

  1. **Version/Zone Not Found**: Ensure you're using the correct version and zone IDs when accessing parameter values.
  2. **Parameter Value Not Updating**: Check if you're using `updateParameterValue` instead of directly modifying the matrix.
  3. **Backend Services Not Responding**: Verify all services are running using the `/status` endpoint on the master server.
  4. **Import/Export Errors**: Ensure that JSON files have the correct matrix structure before importing.

  ## Additional Resources

  - Refer to the `MatrixSubmissionService.js` documentation for API details
  - Check server logs for detailed debugging information
  - Make sure all required dependencies are installed

  By following this guide, you should be able to successfully migrate your application to use the matrix-based form values system while maintaining compatibility with the existing backend services.
